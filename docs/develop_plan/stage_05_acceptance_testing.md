# Этап 5: Критерии приемки и тестирование

## Критерии приемки

Для приёмки реализации стратегии **BaseSignalsMetaBurst** должны быть выполнены следующие условия и пройдены соответствующие тесты:

### 1. Детекция кластеров base_signals

В журнале агрегированных операций группы подопераций модуля base_signals, идущие подряд во времени, отображаются как одна мета-операция.

#### Тесты:
* **Тест**: Смоделировать ситуацию с несколькими подряд вызываемыми `base_signals`-операциями в одном OperationLog (как в примере выше). Убедиться, что в результирующем `operation_log.meta_operations` появляется один объект MetaOperation с heuristic = "BaseSignalsMetaBurst", включающий все эти подоперации.
* **Граничный случай**: Две операции с интервалом **ровно 100 мс** между началом первой и началом второй должны либо считаться кластером (если включаем границы окна включительно), либо нет (если окно полууниверсальное). Определиться с этой бизнес-логикой и протестировать обе ситуации (например, 100ms и 101ms интервал).

### 2. Игнорирование нерелевантных операций

Подоперации, не принадлежащие `base_signals`, не инициируют создание кластеров BaseSignalsMetaBurst.

#### Тесты:
* **Тест**: В OperationLog, где нет ни одной подоперации с source_module = base_signals, стратегия не должна создавать ни одной мета-операции (список `meta_operations` остаётся пустым или содержит кластеры от других стратегий, если те включены). Логирование отработает как раньше.
* **Тест**: В OperationLog, где есть смешанные подоперации (base_signals и другие), проверить, что стратегия группирует только base_signals. Все подоперации, не относящиеся к base_signals (если они не были объединены другими стратегиями), остаются индивидуальными записями.

### 3. Корректная группировка по времени

Стратегия должна объединять **только** те `base_signals`-операции, которые находятся в пределах заданного `window_ms`.

#### Тесты:
* **Тест**: Если в одной операции есть два разных "бурста" base_signals, разделённых паузой больше окна, они должны образовать **два разных** кластера. Например: 3 сигнала подряд, пауза 200 мс, потом ещё 2 сигнала подряд – ожидается два кластера (первый из 3, второй из 2). Проверить, что генерируются 2 MetaOperation с разными meta_id.
* **Тест**: Если сигналы идут равномерно, но с интервалами слегка превышающими окно (например, по 120 мс), убедиться, что они **не** объединяются в один кластер (при окне 100 мс). Стратегия должна быть чувствительна к порогу.

### 4. Учет параметра min_cluster_size

Кластер не должен создаваться из одиночной операции (если min_cluster_size=2).

#### Тесты:
* **Тест**: Сценарий с одной-единственной `base_signals` подоперацией: убедиться, что `detect` возвращает None, и никакого MetaOperation не появляется. Это проверяет уважение настройки min_cluster_size.
* **Тест**: Если в конфигурации min_cluster_size увеличено (например, 3), проверить случай с двумя `base_signals` операциями в пределах окна – кластер не должен формироваться, так как не достигнут порог.

### 5. Маркировка шумовых операций

Все операции, не входящие в кластер, но происходящие в его временном промежутке, фиксируются как шум и отображаются в summary мета-операции.

#### Тесты:
* **Тест**: На примере, подобном описанному (когда между сигналами есть другие операции), проверить текст вывода summary для мета-операции. Он должен содержать указание на наличие шумовых операций (например, `noise: <N>` или перечисление типов), согласно формату, принятому при реализации.
* **Тест**: Убедиться, что сами шумовые операции **не включены** в `sub_operations` кластера. Например, размер `MetaOperation.sub_operations` равен количеству base_signals операций, и при выводе в JSON эти "лишние" шаги не значатся внутри кластера.
* **Тест**: В подробном табличном выводе удостовериться, что шумовые операции не вклиниваются внутрь блока мета-операции, нарушая его целостность. Они могут выводиться как отдельные строки. Формат пометки (например, звездочка или текст *noise*) можно утвердить в ходе реализации, главное – наличие признака.

### 6. Summary содержит актор, шум, длительность

В резюме мета-операции должны присутствовать все три элемента, если они применимы.

#### Тесты:
* **Тест**: Если OperationLog содержит информацию об актере (например, `operation_log.user = "Alice"` или другой параметр), убедиться, что строка описания мета-операции включает эту информацию (e.g. `actor: Alice`).
* **Тест**: Если актор не задан, описание всё равно генерируется, но без упоминания актора (без лишних разделителей/запятых).
* **Тест**: Длительность мета-операции вычисляется правильно: сравнить `total_execution_time` объекта MetaOperation с разницей между временами первой и последней операций – они должны совпадать с точностью до округления. В выводе (s или ms) время отображается в корректной единице и формате, консистентно с остальными частями лога.
* **Тест**: Поле `heuristic` должно равняться "BaseSignalsMetaBurst" (например, в JSON выводе или при отладочной печати), чтобы можно было отличить этот кластер по типу.

### 7. Отключаемость через конфигурацию

При выключенной стратегии система должна вести себя так, словно BaseSignalsMetaBurst не существует.

#### Тесты:
* **Тест**: Установить `META_OPERATION_CONFIG["strategies"]["base_signals_burst"]["enabled"] = False`. Провести ту же ситуацию с последовательными base_signals операциями. Удостовериться, что **никакие** мета-операции BaseSignals не сформировались (подоперации просто перечислены по отдельности хронологически). При этом другие стратегии (если включены) могут сработать, но не объединят именно по признаку base_signals.
* **Тест**: Включить обратно стратегию и убедиться, что кластеризация снова происходит. Это проверяет, что переключение конфигурации эффективно.

### 8. Корректность интеграции и отсутствие побочных эффектов

#### Тесты совместной работы с другими стратегиями:
* **Тест (совместная работа с другими стратегиями)**: Включить все стратегии (TimeWindow, TargetCluster, NameSimilarity, SequenceCount, BaseSignalsMetaBurst) одновременно на подходящем сложном сценарии. Убедиться, что:
  * Не возникает исключений или конфликтов (например, два разных кластера не содержат одну и ту же подоперацию; если такое возможно, детально описать конфликт и решить, например, приоритетом стратегий).
  * В логе не появляется противоречивой информации. Например, одна и та же base_signals операция не должна быть отдельно выведена и одновременно скрыта внутри мета-операции – она должна отображаться только как часть кластера (при `show_individual_operations=False`) либо как часть кластера с пометкой внутри таблицы.
  * Производительность не пострадала заметно: проверка на больших объемах логов (много операций, много подопераций) показывает приемлемое время обработки. BaseSignalsMetaBurst по сложности близка к TimeWindow, её влияние минимально.

#### Тесты отказоустойчивости:
* **Тест (fallback)**: Искусственно вызвать ошибочную ситуацию внутри стратегии (например, передать неверный тип данных в config или сломать логику) и убедиться, что это не ломает процесс логирования целиком. Должно сработать исключение и лог-debug в MetaOperationDetector (как оговорено архитектурой), а основной лог операции всё равно должен быть записан.

## Тестовые сценарии

### Unit тесты

#### Тест 1: Базовая детекция кластера
```python
def test_basic_cluster_detection():
    """Тест базовой функциональности детекции кластера"""
    # Создать 3 base_signals операции в пределах 100ms
    # Проверить, что создается один кластер с 3 операциями
    pass

def test_config_validation():
    """Тест валидации конфигурации"""
    # Проверить корректные параметры
    # Проверить некорректные параметры (отрицательные, нулевые)
    # Проверить значения по умолчанию
    pass

def test_non_base_signals_ignored():
    """Тест игнорирования операций не из base_signals"""
    # Создать операции только из других модулей
    # Убедиться, что кластеры не создаются
    pass
```

#### Тест 2: Временные окна
```python
def test_time_window_boundaries():
    """Тест границ временного окна"""
    # Операции ровно на границе окна (100ms)
    # Операции за пределами окна (101ms)
    # Операции внутри окна (99ms)
    pass

def test_multiple_bursts():
    """Тест множественных burst'ов"""
    # Два отдельных burst'а с паузой между ними
    # Проверить создание двух отдельных кластеров
    pass
```

#### Тест 3: Размер кластера
```python
def test_min_cluster_size():
    """Тест минимального размера кластера"""
    # min_cluster_size = 2, одна операция
    # min_cluster_size = 3, две операции
    # min_cluster_size = 2, три операции
    pass
```

### Integration тесты

#### Тест 4: Интеграция с форматтерами
```python
def test_compact_output_format():
    """Тест compact формата вывода"""
    # Проверить наличие нужных полей в выводе
    # Проверить формат summary строки
    pass

def test_detailed_output_format():
    """Тест detailed формата вывода"""
    # Проверить табличное представление
    # Проверить группировку под мета-кластером
    pass

def test_json_output_format():
    """Тест JSON формата вывода"""
    # Проверить структуру JSON
    # Проверить все обязательные поля
    pass
```

#### Тест 5: Взаимодействие с другими стратегиями
```python
def test_multiple_strategies_no_conflicts():
    """Тест отсутствия конфликтов с другими стратегиями"""
    # Включить все стратегии
    # Проверить отсутствие дублирования кластеров
    pass

def test_strategy_priority():
    """Тест приоритета стратегий"""
    # Проверить, какая стратегия срабатывает при конфликте
    pass
```

### Performance тесты

#### Тест 6: Производительность
```python
def test_performance_large_dataset():
    """Тест производительности на больших объемах"""
    # 1000+ операций в одном логе
    # Измерить время обработки
    # Проверить потребление памяти
    pass

def test_memory_usage():
    """Тест потребления памяти"""
    # Проверить отсутствие утечек памяти
    # Проверить корректную очистку ресурсов
    pass
```

### Acceptance тесты

#### Тест 7: Сквозные сценарии
```python
def test_end_to_end_realistic_scenario():
    """Сквозной тест на реалистичном сценарии"""
    # Смоделировать реальную работу приложения
    # Проверить корректность всего pipeline
    pass

def test_configuration_changes():
    """Тест изменения конфигурации во время работы"""
    # Изменить window_ms
    # Изменить min_cluster_size
    # Включить/выключить стратегию
    pass
```

## Метрики качества

### Функциональные метрики
- **Точность детекции**: 100% корректных кластеров base_signals
- **Полнота детекции**: Все подходящие операции включены в кластеры
- **Специфичность**: Отсутствие ложных срабатываний для не-base_signals операций

### Производительные метрики
- **Время обработки**: Не более 5% overhead от базового логирования
- **Потребление памяти**: Линейный рост относительно количества операций
- **Масштабируемость**: Корректная работа до 10,000 операций в одном логе

### Качественные метрики
- **Читаемость логов**: Улучшение читаемости при наличии burst'ов
- **Информативность**: Вся необходимая информация в summary
- **Конфигурируемость**: Все параметры настраиваются без перекомпиляции

## Инструменты тестирования

### Unit тестирование
- **pytest** - основной фреймворк
- **mock/unittest.mock** - мокирование зависимостей
- **pytest-cov** - покрытие кода

### Integration тестирование
- **pytest-integration** - интеграционные тесты
- **testcontainers** - если нужны изолированные среды

### Performance тестирование
- **pytest-benchmark** - измерение производительности
- **memory_profiler** - анализ потребления памяти
- **cProfile** - профилирование кода

### Acceptance тестирование
- **pytest-bdd** - BDD тестирование
- **allure-pytest** - отчеты о тестировании

## Критерии завершения

При успешном прохождении всех перечисленных тестов стратегия BaseSignalsMetaBurst считается реализованной корректно. Это обеспечит появление в агрегированных логах нового уровня семантического объединения – групп "всплесков" сигналов – без ухудшения работы существующей системы логирования. The strategy will enhance observability by highlighting bursts of base_signals activity, aligning with the extensible plugin-based architecture of meta-operation clustering.

## Цели этапа

1. **Определить критерии приемки** - четкие условия готовности функции
2. **Создать план тестирования** - полный набор тестов для проверки
3. **Определить метрики качества** - количественные показатели успеха
4. **Подготовить инструментарий** - выбрать инструменты тестирования
5. **Создать acceptance tests** - тесты для финальной проверки

## Результаты этапа

- [ ] Определены все критерии приемки с конкретными тестами
- [ ] Создан полный план unit, integration и performance тестов
- [ ] Определены метрики качества и производительности
- [ ] Выбраны инструменты тестирования и настроена среда
- [ ] Созданы acceptance тесты для финальной валидации
- [ ] Документированы критерии завершения этапа
- [ ] Подготовлены реалистичные тестовые данные

## Следующий этап

**Этап 6: Реализация и внедрение** - непосредственная разработка стратегии BaseSignalsMetaBurst согласно всем определенным требованиям и спецификациям.
