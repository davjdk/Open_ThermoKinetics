# Этап 2: Архитектура и проектирование

## Архитектура и реализация

Для реализации стратегии BaseSignalsMetaBurst планируется добавить новый класс (например, `BaseSignalsBurstStrategy`) в модуль стратегий детекции мета-операций (аналогично существующим стратегиям в `detection_strategies.py`). Новый класс будет наследоваться от базового интерфейса `MetaOperationStrategy` (абстракция, которую используют TimeWindowStrategy, TargetClusterStrategy и пр.) и реализовывать необходимые методы.

## Структура класса BaseSignalsBurstStrategy

### 1. Название стратегии
**Свойство `strategy_name`:** должно возвращать уникальное имя стратегии, например `"BaseSignalsMetaBurst"`. Это имя может использоваться в идентификаторах кластеров и для логирования/отладки.

### 2. Валидация конфигурации
**Метод `validate_config(self)`:** Стратегия ожидает в конфигурации наличие определенных параметров. Минимально необходимый параметр – размер временного окна для кластеризации. Название параметра будет, например, `"window_ms"` (в миллисекундах), по аналогии с TimeWindowStrategy, либо `"time_window_ms"` в соответствии с принятым стилем в конфигурации.

**Логика валидации:**
* При отсутствии обязательных параметров или при некорректных значениях (например, отрицательное или нулевое окно) `validate_config` выбрасывает исключение, предотвращая запуск стратегии с неверной конфигурацией.
* Значения по умолчанию: если параметр окна не задан в конфигурации, используется значение **100 мс** как дефолтное окно для "залпа" base_signals-операций.
* Дополнительно можно поддержать параметр `"min_cluster_size"` (по умолчанию 2), чтобы задать минимальное количество подопераций `base_signals` для формирования мета-операции. Это предотвратит создание кластеров из единичных операций.

### 3. Определение кластера (метод `detect`)
**Основная логика стратегии** будет реализована в методе `detect(self, sub_op: SubOperationLog, context: OperationLog) -> Optional[str]`.

#### Алгоритм работы:

1. **Фильтрация по модулю**: Сначала проверяется, относится ли анализируемая подоперация `sub_op` к модулю base_signals. Это может быть определено либо по полю `sub_op.source_module` (равному `"base_signals"`), либо по другим косвенным признакам (например, имя операции или целевой модуль содержат `"base_signals"`). Если подоперация не связана с base_signals, стратегия не применима – возвращается `None` (никакого кластера для этой подоперации стратегия не предлагает).

2. **Подбор операций в окне**: Если `sub_op` инициирован `base_signals`, необходимо собрать группу всех подопераций из текущего контекста (`context.sub_operations`), которые также относятся к `base_signals` и происходят в пределах заданного временного окна относительно рассматриваемой операции.

   * Пусть `t0 = sub_op.start_time` (время начала базовой операции). Стратегия вычисляет окно `[t0, t0 + window]`, где `window` – значение `window_ms`, сконвертированное в секунды для сравнения с `start_time` (так как времена хранятся, предположительно, как timestamps в секундах).
   * Выбираются **все** подоперации `other_op` из `context.sub_operations`, удовлетворяющие условиям:
     * `other_op.source_module == "base_signals"`.
     * `other_op.start_time` находится в диапазоне от `t0` до `t0 + window` включительно (т.е. началась не позже, чем через `window` мс от начала первой операции).
   * Эти операции собираются в список кандидатов `cluster_ops`. Стратегия **не** прерывает окно при наличии "шумовых" операций: если между двумя `base_signals`-операциями вклинилась другая операция, она просто будет пропущена фильтром (но учтена позже как шум), а окно кластеризации продолжается.
   * **Определение границ кластера:** Для найденных `cluster_ops` вычисляется фактическое начало кластера (`cluster_start_time = минимальный start_time` среди `cluster_ops`, обычно будет равен `t0`) и конец кластера (`cluster_end_time = максимальный end_time` среди `cluster_ops`). Таким образом, продолжительность мета-операции составит `cluster_end_time - cluster_start_time`.

3. **Проверка размера кластера**: Если число обнаруженных операций `len(cluster_ops)` меньше минимального размера кластера (`min_cluster_size`, по умолчанию 2), то рассматриваемая операция не образует мета-операцию – возвращается `None`. В противном случае кластер считается найденным.

4. **Формирование идентификатора мета-операции**: При обнаружении группы из двух и более `base_signals`-операций стратегия генерирует идентификатор кластера `meta_id`. Формат идентификатора должен быть уникальным и отражать принадлежность к стратегии BaseSignalsMetaBurst. Например:

   ```python
   meta_id = f"base_signals_burst_{int(cluster_start_time * 1000)}"
   ```

   Здесь в идентификатор включён timestamp начала кластера в миллисекундах (либо может использоваться счётчик кластеров), что делает его уникальным в пределах логирования. Строковый префикс `"base_signals_burst_"` или сокращённый `"bs_burst_"` идентифицирует эвристику.

5. **Возврат результата**: Метод `detect` возвращает `meta_id` для всех подопераций, попавших в кластер. Таким образом, при последовательном анализе подопераций, каждая из `base_signals`-операций в одном "залпе" вернёт одинаковый идентификатор кластера. Это позволит оркестратору собрать их вместе.

### 4. Создание MetaOperation
**Координатор (`MetaOperationDetector`)** на основе возвращённых идентификаторов сгруппирует соответствующие `SubOperationLog` в объект `MetaOperation`. Структура `MetaOperation` уже определена в системе, и включает поля:

* `meta_id` – уникальный идентификатор (сюда попадёт строка вида `"base_signals_burst_X"`).
* `name` – человекочитаемое название мета-операции.
* `heuristic` – имя стратегии, создавшей кластер (например, `"BaseSignalsMetaBurst"`).
* `sub_operations` – список объектов подопераций, вошедших в кластер.
* `cluster_start_time`, `cluster_end_time` – временные границы кластера.
* `total_execution_time` – общая длительность выполнения группы.

Новая стратегия должна корректно формировать эти данные. **Название кластера** (`name`) можно генерировать автоматически, исходя из характера операций:

* По умолчанию: `"BaseSignals Operations"` или `"BaseSignals Burst"` – общее название группы.
* При наличии информации об актере или контексте, название может быть уточнено. Например, если известен пользователь или компонент, инициировавший эти сигналы, можно включить его: `"BaseSignals Burst (actor: ИМЯ)"`. Однако, поскольку имя актора также будет отражено в summary, достаточно краткого названия.
* Название должно ясно показывать, что это кластер, связанный с base_signals, чтобы отличать от мета-операций других типов в выводе.

### 5. Пометка шумовых операций
В реализации стратегии следует предусмотреть механизм фиксации "шума" – операций не из `base_signals`, которые произошли внутри временного интервала кластера:

* Эти посторонние подоперации **не добавляются** в список `sub_operations` мета-операции (чтобы не смешивать с основным содержимым кластера `base_signals`), но информация о них будет собрана для отчёта.
* Один из вариантов реализации – дополнить объект `MetaOperation` дополнительным полем, например `noise_operations: List[SubOperationLog]`, куда стратегия BaseSignalsMetaBurst поместит ссылки на шумовые подоперации, попавшие в окно (их можно определить после формирования кластера, сравнив `cluster_start_time` и `cluster_end_time` с временами начала `SubOperationLog` из другого модуля). Однако, добавление новых полей в `MetaOperation` потребует изменения его определения и форматтера.
* Альтернативный, менее инвазивный подход – **генерировать описание шума динамически** в момент формирования summary-строки (см. ниже). Стратегия, зная границы кластера, может выявить шумовые операции на лету и включить их в текстовое описание, не сохраняя их в структуре.
* В рамках данной реализации предпочтителен второй подход: он не требует изменений существующих структур данных, а всю необходимую информацию о шуме предоставляет в выводе (логах). При этом важно, чтобы лог-форматтер имел доступ к `context` (полной операции) либо чтобы стратегия могла передать список шумовых операций для форматирования.

### 6. Метод описания (summary)
Для стратегии будет реализован метод `get_meta_operation_description(self, meta_id: str, operations: List[SubOperationLog], context: OperationLog) -> str`, отвечающий за генерацию человекочитаемой строки-описания кластера для вывода. В этом методе нужно отразить все требуемые элементы:

* **Актор**: Если в контексте основной операции или в самих подоперациях доступна информация об актере (например, `context.actor` или `context.user`), она включается в описание. Формат может быть такой: `"Actor: <имя_актора>"` или `"User <ид>:"` и т.п. Если актор не определён, этот фрагмент опускается.
* **Основная часть описания**: Указывается, что это кластер base_signals, и сколько операций он в себя включает. Например: `"BaseSignals burst – {N} ops"`. Можно включить длительность: `"за {T} мс"`.
* **Шумовые операции**: Если были посторонние операции в интервале, добавить пометку, например: `"(noise: M ops)"` – где M – количество операций, не относящихся к base_signals, произошедших между первой и последней операциями кластера. **При подробном режиме** можно перечислить их типы или имена, либо хотя бы первый/ключевой, например: `"(noise: ValidationOp, DBCommit)"`. В компактном режиме достаточно указать число шумовых операций или общее наличие шума.
* **Продолжительность**: Общая длительность кластера (в миллисекундах или секундах). Можно указать как в примерах: `0.123 s` или `123 ms` в зависимости от формата вывода.

## Производительность и ограничения
Реализация BaseSignalsMetaBurst не должна вносить значительных задержек в процесс логирования. Поиск связанных операций в окне, в худшем случае, линейно зависит от количества подопераций в контексте. Обычно их число невелико (десятки), поэтому даже переборной поиск по списку приемлем. Можно оптимизировать, выйдя из цикла сбора `cluster_ops` как только разница во времени превышает окно (предполагая, что список подопераций отсортирован по времени/номеру шага). Также стоит учитывать, что одна и та же группа `base_signals`-операций будет обнаружена при вызове `detect` для каждой из них – важно убедиться, что MetaOperationDetector либо избегает дублирования кластеров, либо корректно сливает результаты (см. раздел Интеграция).

## Цели этапа

1. **Спроектировать архитектуру класса** - определить структуру BaseSignalsBurstStrategy
2. **Определить интерфейсы и методы** - спецификация всех публичных методов
3. **Спроектировать алгоритм детекции** - пошаговый алгоритм обнаружения кластеров
4. **Определить структуры данных** - форматы идентификаторов, конфигурации
5. **Спроектировать интеграцию с существующей системой** - взаимодействие с MetaOperationDetector

## Результаты этапа

- [ ] Создана UML-диаграмма класса BaseSignalsBurstStrategy
- [ ] Определены все публичные и приватные методы
- [ ] Задокументирован алгоритм детекции кластеров  
- [ ] Спроектированы структуры данных для конфигурации
- [ ] Определены форматы идентификаторов мета-операций
- [ ] Спроектирована интеграция с MetaOperationDetector
- [ ] Определены оптимизации производительности

## Следующий этап

**Этап 3: Интеграция и конфигурация** - разработка механизмов интеграции стратегии в существующую систему и системы конфигурации.
