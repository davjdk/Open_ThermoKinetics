# Этап 2: Проектирование эвристик детекции и стратегий кластеризации

## Общий подход к эвристикам

Каждая эвристика реализуется отдельным классом с интерфейсом:

```python
class MetaOpStrategy:
    def detect(self, prev: SubOperationLog, curr: SubOperationLog) -> bool:
        """Возвращает True, если две операции относятся к одной мета-операции"""
```

В конфиге указывается порядок и набор активных стратегий.

## Эвристика 1: Кластеризация по времени (Главная эвристика)

### Описание
Объединение операций, стартующих почти одновременно (в пределах настраиваемого окна, например 10–50 мс). Плагин должен обнаруживать группы шагов, временной интервал между началом которых меньше заданного порога, и помечать их как одну метаоперацию.

### Параметры конфигурации
- **time_window_ms**: int (по умолчанию 50–100 мс) - размер временного окна для группировки
- **min_operations**: int (по умолчанию 2) - минимальное количество операций для формирования группы

### Алгоритм
1. Сравнивать время начала текущей операции с предыдущей
2. Если разница ≤ `time_window_ms`, добавить в текущую группу
3. Иначе завершить текущую группу и начать новую
4. Группы с количеством операций < `min_operations` не группируются

### Пример применения
```
Операции с временными метками:
- Op1: 10:00:00.000
- Op2: 10:00:00.030  (разница 30ms < 50ms) → группа
- Op3: 10:00:00.045  (разница 15ms < 50ms) → группа
- Op4: 10:00:00.200  (разница 155ms > 50ms) → новая группа
```

## Эвристика 2: Схожесть имён операций

### Описание
Кластеризация операций с похожими именами. Шаги, начинающиеся с общего префикса (`GET_*`, `LOAD_*`) или относящиеся к одному типу действия, могут рассматриваться как один логический блок.

### Параметры конфигурации
- **name_pattern**: str (regex) - шаблон для группировки имён операций
- **prefix_length**: int (по умолчанию 3) - минимальная длина общего префикса
- **case_sensitive**: bool (по умолчанию False) - учет регистра при сравнении

### Алгоритм
1. Извлечь префикс операции до первого '_' или заданной длины
2. Группировать последовательные операции с одинаковым префиксом
3. Применить дополнительную фильтрацию по regex, если задан

### Примеры паттернов
```python
# Группировка операций получения данных
"GET_.*" → "GET_VALUE", "GET_DF_DATA", "GET_SERIES_VALUE"

# Группировка операций установки значений  
"SET_.*|UPDATE_.*" → "SET_VALUE", "UPDATE_VALUE"

# Группировка по функциональности
".*_CALCULATION" → "MODEL_FIT_CALCULATION", "MODEL_FREE_CALCULATION"
```

## Эвристика 3: Общие параметры запроса

### Описание
Подоперации, направленные на одну и ту же подсистему/модуль (поле `target`) могут логически относиться к одному этапу работы. Плагин группирует последовательные вызовы с одинаковым `target`.

### Параметры конфигурации
- **target_grouping**: bool (по умолчанию True) - группировка по target
- **kwargs_similarity**: float (0.0-1.0) - порог схожести параметров запроса
- **ignore_params**: List[str] - параметры, игнорируемые при сравнении

### Алгоритм
1. Сравнить `target` текущей и предыдущей операций
2. При совпадении `target` проверить схожесть `request_kwargs`
3. Вычислить коэффициент схожести параметров
4. Группировать если схожесть > порога

### Примеры группировки
```python
# Группировка по target
target: "file_data" → операции работы с файловыми данными
target: "series_data" → операции с сериями экспериментов
target: "calculation_data" → операции с расчётными данными

# Группировка по схожим параметрам
kwargs: {"file_name": "test.csv"} → операции с одним файлом
kwargs: {"series_name": "series_1"} → операции с одной серией
```

## Эвристика 4: Маршрут цели (Target-based clustering)

### Описание
Специализированная версия группировки по `target` - собирать операции с одинаковым целевым модулем в логические блоки.

### Параметры конфигурации
- **target_list**: List[str] - список целевых модулей для группировки
- **max_gap**: int - максимальное количество операций другого типа между группируемыми
- **strict_sequence**: bool - требовать строгую последовательность без разрывов

### Реализация
```python
def detect_target_cluster(self, operations: List[SubOperationLog]) -> List[str]:
    """Обнаружение кластеров по target с учётом разрывов"""
    clusters = []
    current_target = None
    current_cluster = []
    gap_count = 0
    
    for op in operations:
        if op.target == current_target:
            current_cluster.append(op)
            gap_count = 0
        elif gap_count < self.max_gap:
            gap_count += 1
        else:
            # Завершить текущий кластер, начать новый
            if len(current_cluster) >= self.min_cluster_size:
                clusters.append(self._create_cluster_id(current_target))
            current_target = op.target
            current_cluster = [op]
            gap_count = 0
    
    return clusters
```

## Эвристика 5: Счётчик подряд идущих шагов

### Описание
Если встречается последовательность из N операций, исполненных без иных шагов между ними, они могут считаться единым метаблоком.

### Параметры конфигурации
- **min_sequence**: int (по умолчанию 3) - минимальная длина последовательности
- **operation_types**: List[str] - типы операций для отслеживания последовательностей
- **status_filter**: List[str] - статусы операций (OK, Error) для группировки

### Алгоритм
1. Отследить последовательности одинаковых операций
2. Подсчитать длину последовательности
3. При достижении `min_sequence` начать группировку
4. Завершить группу при изменении типа операции или статуса

### Примеры последовательностей
```
# Последовательность успешных GET_VALUE
GET_VALUE (OK) → GET_VALUE (OK) → GET_VALUE (OK) = Группа "Batch GET_VALUE (3x)"

# Последовательность ошибок
LOAD_FILE (Error) → LOAD_FILE (Error) = Группа "Failed LOAD attempts (2x)"
```

## Эвристика 6: Порог частоты вызовов

### Описание
Если количество вызовов одного типа превышает `freq_threshold` за `freq_window_ms`, помечать как высокочастотную активность.

### Параметры конфигурации
- **freq_threshold**: int (по умолчанию 5) - пороговое количество вызовов
- **freq_window_ms**: int (по умолчанию 1000) - временное окно для подсчёта
- **operation_whitelist**: List[str] - операции, подлежащие частотному анализу

### Алгоритм
1. Отслеживать количество вызовов каждого типа операции в скользящем окне
2. При превышении порога начать группировку "высокочастотной активности"
3. Завершить группу при падении частоты ниже порога

## Пример детекции мета-операций

### Исходные данные из логов:
```
Операции id=21–28:
- 21: GET_VALUE(file_data) - 10:00:00.000
- 22: SET_VALUE(file_data) - 10:00:00.020  
- 23: UPDATE_VALUE(file_data) - 10:00:00.025
- 24: GET_VALUE(file_data) - 10:00:00.030
- 25: SAVE_DATA(file_data) - 10:00:00.040
- 26: GET_VALUE(series_data) - 10:00:00.200
- 27: SET_VALUE(series_data) - 10:00:00.220
- 28: UPDATE_VALUE(series_data) - 10:00:00.225
```

### Применение эвристик:

**Временная группировка** (window=50ms):
- Группа 1: операции 21-25 (все в пределах 40ms)
- Группа 2: операции 26-28 (все в пределах 25ms)

**Target-based группировка**:
- Группа 1: операции 21-25 (target: file_data)
- Группа 2: операции 26-28 (target: series_data)

**Name similarity** (prefix-based):
- Подгруппа: операции 21,24 (GET_VALUE)
- Подгруппа: операции 22,23,27,28 (SET/UPDATE_VALUE)

### Результирующие мета-операции:
```
Meta-operation "file_data_batch" – STARTED (operations 21-25, 0.040s)
  ├ GET_VALUE → SET_VALUE → UPDATE_VALUE → GET_VALUE → SAVE_DATA
  └ 5 operations, all successful, target: file_data

Meta-operation "series_data_batch" – STARTED (operations 26-28, 0.025s)  
  ├ GET_VALUE → SET_VALUE → UPDATE_VALUE
  └ 3 operations, all successful, target: series_data
```

## Конфигурация стратегий

### Пример файла конфигурации:
```python
META_OPERATION_CONFIG = {
    "enabled": True,
    "strategies": [
        {
            "name": "TimeWindowStrategy",
            "priority": 1,
            "params": {
                "time_window_ms": 50,
                "min_operations": 2
            }
        },
        {
            "name": "TargetClusterStrategy", 
            "priority": 2,
            "params": {
                "target_list": ["file_data", "series_data", "calculation_data"],
                "max_gap": 1
            }
        },
        {
            "name": "NameSimilarityStrategy",
            "priority": 3,
            "params": {
                "name_pattern": "GET_.*|SET_.*|UPDATE_.*",
                "prefix_length": 3
            }
        }
    ]
}
```

## Следующий этап

**Этап 3**: Архитектурное решение и проектирование интерфейсов для реализации описанных стратегий кластеризации.
