
# Техническое задание: MVP обёртка логирования операций

## Общий обзор

Необходимо разработать модуль логирования операций для приложения анализа кинетики твёрдофазных реакций. Этот модуль будет оборачивать выполнение операций, помеченных специальным декоратором, и собирать детальные логи выполнения каждой такой операции. Решение должно интегрироваться с существующей архитектурой приложения и системой логирования, обеспечивая централизованное и удобочитаемое представление последовательности вложенных вызовов. Модуль должен минимально вмешиваться в существующий код, соответствуя архитектурным принципам (слабое связывание, асинхронность через Qt сигналы и event loop и др.) и **не нарушать** коммуникацию компонентов через `BaseSignals`/`BaseSlots`. Ниже перечислены функциональные и нефункциональные требования к MVP-реализации. Располагаться модуль должен в [text](/src/core/log_aggregator/)

## Функциональные требования

### Декоратор `@operation` для методов

* Предоставить декоратор `@operation("OPERATION_NAME")`, которым можно помечать методы классов как логические операции.
* Декоратор должен оборачивать выполнение метода так, чтобы при его вызове фиксировать начало и окончание операции, а также перехватывать все вложенные вызовы, осуществляемые через метод `handle_request_cycle` внутри него.
* Должна поддерживаться вложенность: если внутри операции происходят дополнительные запросы к другим компонентам через `handle_request_cycle`, они считаются **подоперациями** текущей операции. Все такие подоперации должны отслеживаться декоратором (на время выполнения операции декоратор перехватывает вызовы `handle_request_cycle`, например, через прокси-обёртку).
* Начало выполнения операции логируется (например, с отметкой времени и именем операции), после чего выполняется основной код метода. По завершении (успешном или с исключением) декоратор логирует окончание операции и приступает к агрегации собранных данных о подоперациях.

### Агрегация логов подопераций

* Во время выполнения декорированного метода модуль должен собирать информацию о всех вызовах `handle_request_cycle`, сделанных из него. Для каждого такого вызова фиксируется:

  * Имя/тип запрошенной подоперации (например, значение из `OperationType` или указанное имя операции).
  * Параметры или цель вызова (при необходимости, например целевой компонент).
  * Время начала и окончания подоперации (для расчёта длительности).
  * Результат выполнения подоперации: успешно или с ошибкой. Если в ответе подоперации присутствует ключ `data`, определить тип данных результата (`bool`, `dict`, `DataFrame`, др.) и признак успеха (например, в протоколе, где `data={"success": False, "error": "Message"}`, считать подоперацию неуспешной).
* Все собранные данные подопераций агрегируются в структуру (например, список записей), из которой по завершении операции будет сформирована таблица. Агрегация должна производиться с помощью библиотеки `tabulate` для форматированного табличного вывода.
* Вложенные подоперации **не требуют иерархического отображения** – независимо от уровня вложенности все зафиксированные вызовы через `handle_request_cycle` выводятся как единый плоский список шагов текущей операции.

### Отдельный агрегированный лог операций

* Каждая выполненная операция должна логироваться отдельным **агрегированным** блоком, отделённым от обычных логов приложения. Агрегированный лог представляет собой структурированную запись о ходе выполнения операции и её подопераций.
* Агрегированные логи операций сохраняются в отдельный файл (например, `logs/aggregated_operations.log`) с поддержкой ротации файлов по размеру аналогично основной логике логгирования. Этот файл предназначен только для сводных записей по операциям и **не** содержит поток обычных debug/info сообщений.
* Записи об отдельных операциях в агрегированном логе не должны смешиваться друг с другом или с другими логами. Для каждой операции формируется отдельный блок в файле (можно отделять блоки визуально разделителями или метками начала/конца операции). В случае высокой частоты операций допускается запись нескольких операций в один файл с ротацией, но при этом формат должен чётко отделять одну операцию от другой.

### Содержимое агрегированного лога

Каждая запись агрегированного лога (соответствующая одной выполненной операции) должна включать следующие элементы:

* **Заголовок операции**: имя операции (строка из аргумента декоратора, например `"OPERATION_NAME"` или значение `OperationType`), а также метка начала (время начала) и, при желании, уникальный идентификатор выполнения (например, request\_id, если применимо).
* **Статус выполнения**: пометка, чем завершилась операция – *успешно* или *с ошибкой*. Если в ходе выполнения было выброшено исключение либо любая из подопераций завершилась неуспешно и привела к прерыванию, статус операции считается "с ошибкой". В случае успешного выполнения всех шагов – "успешно".
* **Время выполнения**: общее время работы операции от начала до конца (например, в секундах с точностью до миллисекунд). Вычисляется на уровне декоратора (разница между временем начала и окончания выполнения метода).
* **Количество подопераций**: сколько раз в рамках данной операции был вызван `handle_request_cycle` (т.е. общее число подопераций). Каждый вызов рассматривается как отдельный шаг.
* **Таблица подопераций**: перечень всех подопераций (вложенных запросов), выполненных внутри операции. Оформляется в виде таблицы с колонками, например:

  * Номер шага (порядковый номер подоперации в порядке выполнения).
  * Название/тип подоперации (например, `OperationType.TO_DTG` или строковое имя).
  * Целевой компонент или модуль, к которому шёл запрос (например, `'file_data'`, `'calculations_data'` – берётся из параметра `target` запроса).
  * **Тип данных результата** подоперации – определён из поля ответа `data` (например, *bool*, *float*, *str*, *dict*, *DataFrame*, **None** и т.д.). Если `data` содержит структуру с `success/error`, можно указать тип как *ErrorDict* или просто *dict*.
  * Статус подоперации: *OK* (если успешно) или *Error* (если произошло исключение или неуспешный ответ).
  * Время выполнения подоперации (если замерять отдельно, иначе можно опустить или включить в описание).
* **Результаты подопераций**: в каждой строке таблицы подопераций можно кратко отразить результат, если он важен. Однако, подробные данные результатов обычно есть в `data` и могут быть сложными (например, большие структуры), поэтому в таблице достаточно указать тип данных или ключевую информацию. Детали ошибок (сообщение об ошибке) для неуспешных подопераций можно вынести либо в отдельную колонку, либо оформить сноской под таблицей.
* **Итоговая строка/блок резюме**: после таблицы подопераций добавить краткое резюме по операции: общее число шагов, количество успешных из них, количество неуспешных, и общее время выполнения операции. Резюме можно оформить отдельной строкой (например, *“Итого: 5 шагов, успешно: 4, с ошибками: 1, общее время: 3.2 s”*) либо небольшой отдельной таблицей без заголовка.

Пример структуры раздела агрегированного лога для одной операции (для иллюстрации):

```
Операция "TO_DTG" – НАЧАЛО (id=1234, 2025-06-15 14:06:38)  
...  
| Шаг | Подоперация         | Цель           | Тип данных результата | Статус | Время, с |  
|---:|---------------------|----------------|-----------------------|--------|---------|  
| 1  | OperationType.TO_A_T| active_file_ops| function              | OK     | 0.120   |  
| 2  | OperationType.TO_A_T| file_data      | bool                  | OK     | 0.089   |  
| 3  | OperationType.TO_DTG| file_data      | bool                  | Error  | 0.010   |  
...  
ИТОГО: шагов 3, успешно 2, с ошибками 1, общее время 0.250 с.  
Операция "TO_DTG" – ЗАВЕРШЕНО (статус: **с ошибкой**)  
```

*(Приведено условно для пояснения; фактический формат может отличаться, но должен быть близок по информативности.)*

### Обработка ошибок внутри операции

* В случае, если в процессе выполнения декорированного метода возникает исключение или ошибка, декоратор должен перехватить её после того, как метод завершится, зафиксировать факт ошибки и статус операции "с ошибкой", а затем продолжить процедуру логирования (агрегации логов подопераций и записи в файл). Это гарантирует, что даже при сбое в середине операции уже выполненные подоперации будут отражены в агрегированном логе, а сама операция получит запись о неуспешном завершении.
* Предусмотреть механизм-хук для дополнительной обработки и форматирования ошибок. В текущем MVP можно заложить возможность подключения кастомной функции обработки ошибок: например, если операция завершается с исключением, вызывать специальный обработчик (если он зарегистрирован) для формирования расширенного сообщения об ошибке или выполнения дополнительных действий (отправка сигнала, очистка ресурсов и т.п.). Пока этот хук может быть заглушкой (placeholder), просто фиксирующей факт ошибки, но архитектура должна позволять его реализацию в будущем.
* В агрегированном логе ошибки должны быть отображены ясно: для подопераций, завершившихся с ошибкой, указать статус “Error” и, по возможности, краткое описание ошибки (например, текст исключения) – либо в рамках таблицы, либо сразу под ней. Для самой операции при ошибке в заголовке/итоговом блоке отметить, что операция неуспешна, и записать тип и сообщение исключения (например: *«RuntimeError: file not found»*).

### Расширяемость и будущее развитие

* Разработанный модуль должен быть спроектирован с расчётом на будущие расширения. В перспективе может понадобиться логирование **“потоков вычислений”** или других сущностей, параллельных операций и т.д. Это означает, что архитектура решения должна допускать:

  * Лёгкое добавление новых типов отслеживаемых сущностей (например, если появятся разные типы операций или параллельные задачи, их тоже можно оборачивать подобным образом).
  * Возможность группировать логирование по контекстам или потокам. Например, если в будущем операция может выполняться в фоне или в нескольких потоках, может потребоваться идентификатор потока/сценария для группировки логов. Закладывать эту возможность (например, через параметр декоратора или внутренний контекст) стоит заранее, хотя реализация полного функционала не требуется в MVP.
  * Следование принципам модульности и слабого связывания: новый функционал должен добавляться через расширение (например, новые декораторы или подклассы), а не изменения существующего кода, где это возможно. **Расширяемость** является одним из архитектурных принципов проекта, поэтому решение должно органично поддерживать добавление новых возможностей без ломки существующего кода.

## Нефункциональные требования и интеграция

### Минимальное вмешательство в существующий код

* Основная точка интеграции решения – декоратор `@operation`. Его использование не должно требовать изменений внутри логики самих методов операций; достаточно добавить декоратор на объявления нужных методов.
* При необходимости перехвата вызовов `handle_request_cycle` следует реализовать это через прокси-обёртку или наследование, **не изменяя** исходный код `BaseSlots` или компонентов. Например, можно создать обёртку вокруг метода `handle_request_cycle` на время выполнения операции: декоратор в начале операции подменяет (или оборачивает) метод `handle_request_cycle` текущего объекта на свою версию, собирающую данные, и восстанавливает оригинальный метод после завершения. Такой подход изолирует изменения и не требует модификации базовых классов.
* Вся дополнительная логика сбора и агрегирования должна быть максимально прозрачной для остальной системы. То есть, кроме самого факта наличия декоратора, поведение операций для остальной части приложения не меняется: коммуникация через сигналы/слоты идёт как и раньше, результаты операций возвращаются в том же виде (декоратор может просто вернуть результат оригинального метода), а задержки на логирование минимальны.
* При интеграции убедиться, что поведение `BaseSignals`/`BaseSlots` не нарушается: декоратор не должен блокировать event loop дольше, чем сама операция, или вызывать дополнительные сигналы. Он лишь фиксирует время и данные. Асинхронная модель (запрос-ответ через сигнал) при этом сохраняется – декоратор работает **синхронно вокруг** вызова, не превращая его в полностью последовательный вне уже существующей блокировки QEventLoop (которая и так используется для синхронизации запросов).

### Интеграция с системой логирования

* Новый модуль обязан использовать существующую инфраструктуру логирования (`LoggerManager` в `logger_config.py`). В частности:

  * Получение логгеров должно происходить через текущую фабрику логгеров: например, `logger = LoggerManager.get_logger(__name__)`, чтобы новый код логирования вписался в общую иерархию логгеров приложения и не создавал дублирующихся конфигураций.
  * Для записи агрегированных логов целесообразно либо завести отдельный логгер (например, с именем `solid_state_kinetics.operations` или подобным), либо использовать существующий root-логгер, но с отдельным **handler** на файл `aggregated_operations.log`. Предпочтительнее первый вариант (отдельный логгер), чтобы можно было настроить для него уровень логирования и обработчики независимо.
  * Реализовать файл логов `aggregated_operations.log` по аналогии с основным файлом логов: в директории `logs/`, с ротацией по размеру (порог и backup\_count можно взять те же или настроить отдельно). Использовать ту же схему форматирования (время, уровень, источник) для строк заголовков/резюме, чтобы логи были единообразны. Однако, строки таблицы могут выводиться без префикса времени/уровня (проще читать чистую таблицу); это допустимо, так как таблица сама является частью сообщения агрегированного логгера.
  * Удостовериться, что при конфигурировании логирования через `LoggerManager.configure_logging()` новый файл подключается корректно. Возможно, придётся изменить `LoggerManager.configure_logging` для инициализации файла aggregated\_operations.log, либо после его вызова программно добавить handler. В любом случае, **нельзя** хардкодить логирование, минуя LoggerManager; следует расширить существующую систему конфигурации.

### Соответствие архитектуре и принципам проекта

* Решение должно улучшать **трассируемость операций** и удовлетворять требованию централизованного логирования, отмеченному в архитектурном описании (надежность через централизованное логирование операций). Новая функциональность не должна противоречить этому: фактически, агрегированный лог расширяет централизованное логирование, делая его более структурированным.
* Соблюдать **слабое связывание**: модуль логирования не должен жёстко зависеть от конкретной реализации операций. Он оперирует стандартными интерфейсами (`@operation` декорирует метод, использует `handle_request_cycle` для сбора данных) и не требует специфичных знаний о содержимом операций. Это позволяет при добавлении новых операций или компонентов автоматически получить их поддержку (достаточно применить декоратор).
* Обеспечить **модульность**: реализованный функционал выделен в отдельном модуле/классе (например, `operation_logger.py`), который можно при необходимости изменять или заменять без затрагивания остальной системы. Компоненты системы взаимодействуют с ним только через декоратор или вызовы логгера.
* **Асинхронность** и использование Qt event loop: не нарушать модель работы с сигналами. Декоратор должен работать корректно как для операций, вызываемых напрямую (синхронно), так и для операций, инициированных через события UI и обрабатываемых в event loop. Поскольку `handle_request_cycle` в `BaseSlots` уже синхронизирует запрос через QEventLoop, дополнительных блокировок не требуется. Важна отзывчивость UI: логирование не должно заметно задерживать ответ пользователю. Использование `tabulate` и запись в файл выполняются после получения ответа (уже в синхронном контексте), что минимизирует влияние на время отклика.
* Учитывать **многопоточность**: если в текущей версии приложения все операции исполняются в едином потоке GUI (с блокировкой на время запросов), то конфликты логирования маловероятны. Однако, если в будущем появятся фоновые потоки, нужно убедиться, что доступ к общим ресурсам логирования потокобезопасен (стандартный `logging` в Python потокобезопасен). Можно предусмотреть синхронизацию при записи агрегированных таблиц, если они формируются вне GIL.

## Структура таблицы логов операций

Структура таблицы, формируемой для подопераций, должна быть консистентной и удобочитаемой. Требования к таблице:

* Использовать `tabulate` для автоформатирования. Формат таблицы – простой (например, grid или plain) текст, чтобы её можно было просматривать в лог-файле без специального ПО.
* Таблица должна содержать колонки, перечисленные в разделе выше (номер шага, имя подоперации, цель/компонент, тип результата, статус, время). Для узких логов можно опустить некоторые колонки (например, если время каждой подоперации не критично, можно не выводить). Главное – все ключевые сведения по каждому шагу видны.
* Шапка таблицы (названия колонок) может быть выведена один раз перед списком подопераций. Либо, если используется формат без границ, можно просто выровнять столбцы пробелами. **Пример оформления** (см. выше) демонстрирует подход с заголовком.
* Выравнивание в колонках: номера шагов по правому краю, текстовые поля по левому, статус можно выделять (например, OK/Error разными символами или оставлять как есть). Главное – читать должно быть легко.
* После таблицы явно отделять блок резюме (например, пустой строкой или чертой). Можно повторно указать имя операции и статус завершения для наглядности.

## Сценарии ошибок и логирование

Рассмотреть возможные нештатные ситуации и как модуль логирования должен на них реагировать:

* **Ошибка в подоперации, не прерывающая всю операцию**: например, одна из подопераций вернула ошибочный результат (`data.success=False`), но код декорированного метода обработал это и продолжил другие подоперации. В этом случае:

  * В таблице подоперация помечается как *Error* и фиксируется тип ее `data` (вероятно, `dict` с описанием ошибки).
  * Общий статус операции может остаться "успешно", если с точки зрения логики верхнего уровня ошибка подоперации была ожидаемой/обработанной и не помешала итоговому результату. (Например, запрос мог быть пробным.)
  * В резюме количество неуспешных шагов увеличено, но итоговый статус "успешно" (если действительно операция в целом считается выполненной). В противном случае, если даже обработанная внутренняя ошибка должна считать всю операцию неуспешной, то и статус операции будет "с ошибкой". Требуется определить политику в контексте бизнес-логики; в MVP можно считать, что **любая необработанная ошибка или исключение делает операцию неуспешной**, а обработанные внутренние ошибки — часть нормального сценария, не влияющая на итог.
* **Исключение в ходе выполнения операции**: если декорированный метод выбросил исключение (не пойманное внутри него), декоратор должен:

  * Зафиксировать последнюю подоперацию (если она была начата и привела к исключению). Возможно, исключение прервет метод до того, как `handle_request_cycle` вернётся, тогда стоит пометить эту подоперацию как прерванную с ошибкой. Если исключение не связано напрямую с подоперацией (например, ошибка в вычислениях между вызовами), подоперации до этого уже будут записаны, а новая не началась – тогда просто будет меньше шагов, чем могло быть.
  * В заголовке или под таблицей отметить, что операция завершилась исключением, указать тип исключения и сообщение.
  * Статус операции = "с ошибкой". В резюме успешные/неуспешные шаги подсчитываются (последний шаг, где упало, считается неуспешным).
  * **Важно**: После логирования декоратор может либо проглотить исключение, либо пробросить его дальше. В контексте логирования, вероятно, лучше не подавлять исключение (чтобы внешние механизмы знали о сбое), но тогда следует осторожно делать логирование до re-raise. Решение: декоратор ловит исключение, логирует всё должным образом, затем может перевыбросить его (если вызывающая сторона должна обработать). Это следует указать в реализации, хотя в ТЗ достаточно сказать, что ошибки логируются, а способ распространения ошибки – на усмотрение архитектуры (возможно, глобальный обработчик ошибок GUI ее поймает).
* **Сбой логирования**: теоретически, формирование таблицы или запись в файл могут сами дать сбой (например, проблема с файловой системой). Такое должно приводить к минимальному ущербу: ошибка логирования не должна остановить приложение. Нужно обернуть операции записи в файл в try/except и, в случае неудачи, как минимум вывести предупреждение через стандартный логгер (`logger.error`), что не удалось сохранить агрегированный лог. Однако, подобные ошибки маловероятны и могут не прорабатываться подробно в MVP.

## Требования к тестированию

### Юнит-тесты декоратора и логирования

* Разработать модульные тесты для проверки работы декоратора `@operation` и сопутствующей логики:

  * **Корректность обёртки**: убедиться, что декорированный метод при вызове выполняется, возвращает оригинальный результат, и при этом производится запись в агрегированный лог нужных данных. Можно замокать вызов `handle_request_cycle` внутри тестового метода, чтобы проверить сбор информации.
  * **Сбор подопераций**: написать тест, где декорированный метод вызывает несколько раз `handle_request_cycle` (например, имитировать два-три вызова с разными возвращаемыми значениями). Проверить, что по завершении операции собрано корректное количество подопераций, и что их данные (имена операций, типы результатов, статусы) совпадают с ожидаемыми.
  * **Вложенные вызовы**: имитировать ситуацию, когда один из вызовов `handle_request_cycle` внутри операции сам по себе инициирует другой внутренний запрос (например, через вызов другого метода, который тоже использует `handle_request_cycle`). Все эти вызовы должны появиться в общем списке. (Для MVP может быть сложно искусственно вызвать двойную вложенность без настоящей архитектуры сигналов; допускается смоделировать её, например, вызывая внутри подоперации ещё одну функцию, обёрнутую декоратором, или вручную вызывая логгер). Главное – проверить, что **все** вызовы учтены.
  * **Обработка ошибок**: тест на случай, когда декорированный метод бросает исключение. Убедиться, что декоратор ловит его, логирует завершение с ошибкой и перевыбрасывает (если так задумано). Проверить, что агрегированный лог содержит правильный статус и информацию об ошибке.
  * **Ошибка в подоперации**: смоделировать, что `handle_request_cycle` возвращает неуспешный ответ (например, `{'success': False, 'error': '...'}`). Декорированный метод при этом может либо бросить исключение, либо продолжить работу. Протестировать оба варианта:

    * Если исключение не бросается (ошибка обработана внутри метода), операция считается успешной, но лог должен содержать подоперацию со статусом Error.
    * Если вызывается исключение вслед за ошибкой подоперации, см. предыдущий пункт (операция с ошибкой).
  * **Форматирование таблицы**: можно протестировать генерацию таблицы `tabulate` на небольшом наборе данных (например, 2-3 подоперации) и сравнить получившуюся строку или структуру с ожидаемой (или хотя бы проверить наличие заголовков и строк). Строгое сравнение текстовой таблицы может быть затруднительным из-за форматирования, поэтому достаточно убедиться, что табличные данные соответствуют входным.
* Каждый тест должен запускаться в изолированном окружении, чтобы логи одной операции не влияли на другую. Можно использовать временный файл для агрегированных логов (или перенаправить логгер на `io.StringIO`) в тестовом режиме, чтобы проанализировать его содержимое.

### Покрытие тестами

* Покрытие кода нового модуля должно быть максимально полным (стремиться к 90-100% ключевой логики). Особое внимание уделить различным путям выполнения: нормальный сценарий, сценарий с ошибкой, отсутствие подопераций, одна подоперация, несколько подопераций и т.д.
* Все типы операций, определённые в `OperationType`, должны иметь как минимум один тест-кейс, подтверждающий корректность логирования для данного типа. Практически это можно сделать, создав фиктивные методы, декорированные `@operation` и имитирующие выполнение операций этих типов (т.к. сами операции могут быть разнообразными, достаточно проверить, что имя/enum `OperationType` логируется правильно и не влияет на механизм). Это требование гарантирует совместимость со всей системой типов операций.
* Тесты на интеграцию с `LoggerManager`: убедиться, что при инициализации логирования агрегированный файл создаётся и пишет данные. Например, после вызова декорированной операции проверить, что файл `aggregated_operations.log` (или его тестовый аналог) содержит запись. Также проверить, что формат записей соответствует ожиданиям (наличие имени операции, статуса, таблицы).
* Желательно статически проанализировать, что применение декоратора не изменяет сигнатуру методов (т.е. методы по-прежнему принимают и возвращают те же данные). Для этого можно написать тест, вызывающий декорированный метод и сравнивающий результат с ожиданием (например, если без декоратора метод возвращал True, то с декоратором тоже возвращает True).

## Соответствие текущей архитектуре

Предлагаемое решение вписывается в текущую архитектуру приложения: оно усиливает централизованное логирование (выделяя в отдельный файл сводки по операциям) и повышает трассируемость, что прямо соответствует архитектурным целям. Коммуникация модулей остаётся через `BaseSignals`/`BaseSlots`, декоратор лишь регистрирует обмен сообщениями, не вмешиваясь в него. Благодаря слабому связыванию и модульности, новая функциональность добавляется без модификации существующего кода (кроме декорирования нужных методов). Асинхронность через сигналы и event loop сохраняется – логирование обрабатывается после получения ответа, не блокируя поток сообщений. В итоге, решение обеспечивает требуемое **MVP**-поведение: разработчики смогут легко просматривать ход выполнения сложных операций (состоящих из нескольких подзапросов) в читаемом табличном формате, а архитектура приложения при этом остаётся стройной и расширяемой.
