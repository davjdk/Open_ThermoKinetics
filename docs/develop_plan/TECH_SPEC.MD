# Техн**Основная идея:** **Основная идея:** если**** **Исключение операций   Пример формата summary для г      operation_types = [op.operation_name for op in operations]
      actor_text = actor if actor else "не задан"
      types_text = ", ".join(set(operation_types))
      return f"BaseSignalsBurst: {count} операции ({types_text}), {duration_ms} мс, actor: {actor_text}"ы: *«BaseSignalsBurst: 3 операции (SET_VALUE, GET_VALUE, SET_VALUE), 2 мс, actor: не задан»*. Такой summary будет отображаться в отчёте, давая мгновенное представление о характере мета-операции. **Типы операций**: краткий список типов операций в кластере (например, "SET_VALUE, GET_VALUE"). подоперациями:** Операции, имеющие вложенные подоперации (sub_operations_count > 0), НЕ включаются в кластеры BaseSignalsMetaBurst, так как они представляют сложные бизнес-операции, а не простые сигналы.
* **Минимальный состав кластера:** Кластер создаётся при наличии хотя бы **2 последовательных операций** из `base_signals.py:51` в пределах временного окна. Одиночные операции не группируются.*Идентификация операций base_signals:** К стратегии относятся только операции, у которых в caller_info указан источник `"base_signals.py:51"` и которые НЕ имеют вложенных подопераций ("No sub-operations recorded"). Такие операции характеризуются быстрым выполнением (0.000-0.001 сек) и типами SET_VALUE, GET_VALUE, UPDATE_VALUE.**Последовательность вызовов:** Кластер **BaseSignalsMetaBurst** формируется, когда за одной операцией `base_signals.py:51` **следует** другая операция из того же источника с интервалом ≤ 100 мс. Если между двумя операциями проходит больше установленного порога времени, считается, что предыдущий *бурст* закончился.* **Идентификация операций base_signals:** К стратегии относятся только операции, у которых в caller_info указан источник `"base_signals.py:51"` и которые НЕ имеют вложенных подопераций ("No sub-operations recorded"). Такие операции характеризуются быстрым выполнением (0.000-0.001 сек) и типами SET_VALUE, GET_VALUE, UPDATE_VALUE.*Временное окно кластеризации:** Одиночные операции из `base_signals.py` группируются, если их времена начала находятся в пределах заданного окна – по умолчанию **100 мс** друг от друга. Значение окна должно быть конфигурируемым параметром (например, `window_ms`) в настройках стратегии.несколько одиночных операций из `base_signals.py` (строка 51) идут подряд в пределах короткого промежутка времени (дефолтно 100 мс), они рассматриваются как единый *"бурст"* (burst) сигналов. Характерная особенность таких операций:
- **Нет вложенных подопераций**: "No sub-operations recorded"
- **Быстрое выполнение**: время выполнения 0.000-0.001 секунды
- **Последовательные вызовы**: операции типа SET_VALUE, GET_VALUE, UPDATE_VALUE
- **Общий источник**: все вызываются из `base_signals.py:51`

Пример целевых операций для кластеризации:
```
base_signals.py:51 "SET_VALUE" (id=44, 2025-06-17 20:39:52)
No sub-operations recorded.
SUMMARY: steps 0, successful 0, with errors 0, total time 0.001 s.

base_signals.py:51 "GET_VALUE" (id=45, 2025-06-17 20:39:52)  
No sub-operations recorded.
SUMMARY: steps 0, successful 0, with errors 0, total time 0.000 s.

base_signals.py:51 "SET_VALUE" (id=46, 2025-06-17 20:39:52)
No sub-operations recorded.
SUMMARY: steps 0, successful 0, with errors 0, total time 0.001 s.
```сли несколько одиночных операций из `base_signals.py` (строка 51) идут подряд в пределах короткого промежутка времени (дефолтно 100 мс), они рассматриваются как единый *"бурст"* (burst) сигналов. Характерная особенность таких операций:
- **Нет вложенных подопераций**: "No sub-operations recorded"
- **Быстрое выполнение**: время выполнения 0.000-0.001 секунды
- **Последовательные вызовы**: операции типа SET_VALUE, GET_VALUE, UPDATE_VALUE
- **Общий источник**: все вызываются из `base_signals.py:51`

Пример целевых операций для кластеризации:
```
base_signals.py:51 "SET_VALUE" (id=44, 2025-06-17 20:39:52)
No sub-operations recorded.
SUMMARY: steps 0, successful 0, with errors 0, total time 0.001 s.

base_signals.py:51 "GET_VALUE" (id=45, 2025-06-17 20:39:52)  
No sub-operations recorded.
SUMMARY: steps 0, successful 0, with errors 0, total time 0.000 s.

base_signals.py:51 "SET_VALUE" (id=46, 2025-06-17 20:39:52)
No sub-operations recorded.
SUMMARY: steps 0, successful 0, with errors 0, total time 0.001 s.
```ческое задание: эвристика кластеризации метаопераций **BaseSignalsMetaBurst**

## Обзор и цели

**BaseSignalsMetaBurst** – новая эвристика для кластеризации одиночных операций в системе агрегированного логирования. Цель данной стратегии – автоматически объединять серии быстрых одиночных операций, инициированных из модуля **`base_signals.py`**, в единый кластер (мета-операцию) при анализе завершённых логов. Это улучшит читаемость логов и позволит трактовать серию быстрых вызовов `base_signals` как одну логическую операцию. Кластеризация происходит **постфактум** – после завершения основной операции, на этапе анализа `OperationLog` (не вмешиваясь в выполнение бизнес-логики).

**Основная идея:** если в ходе одной основной операции несколько вызовов модуля `base_signals` идут подряд в пределах короткого промежутка времени (дефолтно 100 мс), они рассматриваются как единый *“бурст”* (burst) сигналов. Все такие вызовы будут сгруппированы в мета-операцию **BaseSignalsMetaBurst**. Вызовы других модулей, попавшие **между** этими вызовами `base_signals`, считаются **«шумом»** – они будут включены в кластер, но помечены специально как посторонние, чтобы их можно было отличить от основных операций `base_signals`.

## Условия и логика кластеризации

* **Временное окно кластеризации:** Подоперации с модулем-инициатором `base_signals` группируются, если их времена начала находятся в пределах заданного окна – по умолчанию **100 мс** друг от друга. Значение окна должно быть конфигурируемым параметром (например, `window_ms`) в настройках стратегии.
* **Последовательность вызовов:** Кластер **BaseSignalsMetaBurst** формируется, когда за одним вызовом `base_signals` **следует** другой вызов `base_signals` с интервалом ≤ 100 мс. Все промежуточные подоперации (если они есть) также включаются в этот кластер как его часть. Если между двумя вызовами `base_signals` проходит больше установленного порога времени, считается, что предыдущий *бурст* закончился, и следующий вызов `base_signals` может инициировать новый кластер.
* **Идентификация “base\_signals” операций:** К стратегии относятся только подоперации, у которых **source/target модуль** (или аналогичное поле) равен `"base_signals"` (то есть операция действительно инициирована модулем base\_signals). Другие подоперации в пределах окна, чей модуль отличается, помечаются как шумовые.
* **Шумовые операции:** Если между вызовами `base_signals` присутствуют подоперации из **других модулей**, они включаются в кластер, но помечаются как **`noise`**. Это означает, что они не являются частью последовательности `base_signals`, а лишь произошли “между” ними. Стратегия должна явно обозначать такие подоперации, чтобы в итоговом логе было понятно, какие шаги внутри мета-операции являются «шумом». (Например, можно отметить их специальным флагом или добавить к их описанию метку `"noise"`.)
* **Минимальный состав кластера:** Кластер **не должен создаваться**, если внутри временного окна **нет ни одной** реальной операции `base_signals` (то есть все собранные подоперации оказались шумом). Иными словами, группа формируется только если она содержит хотя бы одну подоперацию модуля `base_signals`. В противном случае такой кластер отбрасывается.

## Формирование мета-операции BaseSignalsMetaBurst

Для каждой обнаруженной группы операций `base_signals.py:51` стратегия создаёт объект мета-операции (структура **MetaOperation**). Требования к содержимому мета-операции:

* **Список операций (`operations`):** все одиночные операции, вошедшие в кластер – только вызовы из `base_signals.py:51` без вложенных подопераций – должны быть сохранены в списке операций мета-операции. Порядок операций в списке должен соответствовать порядку их выполнения (по времени).

* **Атрибуты исходного вызова:** при формировании мета-операции важно сохранить контекст. Необходимо заполнить поля:
  * **`source_module`** – указывается как `"base_signals.py"`, поскольку кластер посвящён вызовам именно из этого модуля.
  * **`caller_info`** – передать информацию о вызове `"base_signals.py:51"`, общую для всех операций в кластере. Это поможет идентифицировать источник бурста сигналов.
  * **`actor`** – если в контексте логирования предусмотрено понятие актора, его следует указать для мета-операции. Если актор не определён, то в **сводке** кластера нужно явно указать, что *actor не определён*.

* **Время и длительность кластера:** мета-операция должна содержать время начала кластера (`cluster_start_time`) и окончания (`cluster_end_time`), а также рассчитанную общую длительность (`total_execution_time`). Начало кластера – это время начала первой операции `base_signals.py:51` в группе, окончание – время окончания последней операции. Длительность рассчитывается как разница `cluster_end_time - cluster_start_time`.

* **Идентификатор и имя мета-операции:** каждой сгруппированной пачке присваивается уникальный **`meta_id`** (строка). Можно, например, сгенерировать ID на основе времени начала первого вызова (как делается в стратегии по окну времени), либо на основе номера шага первого элемента. Например: `meta_id = "base_signals_burst_{first_step}"` или `base_signals_burst_{timestamp}`. Человекочитаемое имя группы (`name`) можно задать как `"BaseSignals Burst"` или `"BaseSignalsMetaBurst"` для отображения в логах.

* **Summary (сводка кластера):** для кластерной мета-операции необходимо сформировать краткое описание, включающее:

  * Общее **количество операций** в группе.
  * **Общую длительность** выполнения кластерной последовательности (например, в миллисекундах или секундах).
  * **Actor** (если определён; если нет – указать, что *actor не указан*).
  * **Наличие шума:** отметить, присутствовали ли в группе посторонние вызовы других модулей. Достаточно бинарного флага (например, *“шум: есть”* / *“шум: нет”*), но при желании можно указать и количество шумовых операций или перечислить модули, откуда был шум.

Пример формата summary для группы: *«BaseSignalsBurst: 5 операций, 82 мс, actor: не задан, шум: есть»*. Такой summary будет отображаться в отчёте, давая мгновенное представление о характере мета-операции. (В данном примере в кластер вошло 5 подопераций за 82 мс, актор не определён, и внутри присутствуют шумовые вызовы.)

## Структура класса стратегии **BaseSignalsBurstStrategy**

Новая стратегия будет реализована в виде класса **`BaseSignalsBurstStrategy`**, добавленного в модуль `detection_strategies.py` наряду с другими стратегиями. Этот класс должен расширять абстрактный базовый класс `MetaOperationStrategy`, следуя его интерфейсу. Ключевые элементы реализации:

* **Свойство `strategy_name`:** вернуть уникальное имя стратегии, например `"BaseSignalsBurst"`. Это имя может использоваться для регистрации стратегии и для отладки (логгер стратегии и т.п.).

* **Метод `validate_config(self)`:** проверить, что в конфигурации присутствуют необходимые параметры. Как минимум, ожидается параметр временного окна, например `"window_ms"` (типа float или int, > 0). При отсутствии параметра или недопустимом значении метод должен вызывать ошибку конфигурации (ValueError) с пояснением, аналогично тому как это сделано в других стратегиях (например, TimeWindowStrategy проверяет наличие `window_ms` и что он > 0). Также можно предусмотреть параметр `"enabled"` в конфиге (но его обработкой в основном занимается MetaOperationConfig).

* **Метод `detect(self, operation_log: OperationLog, context: List[OperationLog]) -> Optional[str]`:** основной метод определения принадлежности операции к кластеру. Логика метода:

  1. Проверить, является ли операция целевой для кластеризации: если `operation_log` НЕ инициирована из `"base_signals.py:51"` или имеет вложенные подоперации (`sub_operations_count > 0`), стратегия возвращает `None`.
  2. Если операция является целевой (одиночная операция из `base_signals.py:51` без подопераций), найти группу всех близко расположенных по времени аналогичных операций:
     * Просмотреть операции до и после текущей в контексте `context`, отфильтровать только операции из `"base_signals.py:51"` без подопераций.
     * Выбрать все соседние операции, у которых разница во времени `start_time` с текущей не превышает `window_ms`.
  3. Определить, удовлетворяет ли найденная группа критериям кластера: в группе должно быть хотя бы 2 операции.
  4. Если группа валидна, сгенерировать `meta_id` для кластера и вернуть его.

  Метод `detect` должен учитывать, что стратегии выполняются последовательно в порядке приоритета. Если эта стратегия сработала и пометила операцию кластером, дальнейшие стратегии для неё уже не выполняются. Поэтому внутри `detect` нужно максимально точно определить кластер сразу, чтобы все относящиеся операции получили единый `meta_id`.

* **Метод `get_meta_operation_description(self, meta_id: str, operations: List[OperationLog]) -> str`:** генерирует человекочитаемое описание для кластера, которое будет отображено в логе (например, как заголовок мета-операции). Для BaseSignalsMetaBurst это описание должно содержать сводку, о которой говорилось выше. Например:

  ```python
  def get_meta_operation_description(...):
      count = len(operations)
      duration_ms = int((operations[-1].end_time - operations[0].start_time) * 1000) if operations else 0
      actor = operations[0].actor if hasattr(operations[0], "actor") else None
      noise_present = any(op.target != "base_signals" for op in operations)
      actor_text = actor if actor else "не задан"
      noise_text = "есть" if noise_present else "нет"
      return f"BaseSignalsBurst: {count} операций, {duration_ms} мс, actor: {actor_text}, шум: {noise_text}"
  ```

  *(Примечание: код приведён для иллюстрации структуры; реализация может отличаться в зависимости от доступности полей `actor` и форматов времени.)*

  Такой вывод даст понятное описание кластеру при форматированном выводе.

## Конфигурация и интеграция стратегии

Новая эвристика должна быть интегрирована в существующую архитектуру агрегированного логирования таким образом, чтобы обеспечить её гибкое включение/отключение и настройку, без нарушения работы других компонентов (следуя принципу расширяемости). Основные шаги интеграции:

* **Регистрация стратегии:** внести класс `BaseSignalsBurstStrategy` в реестр стратегий. В `MetaOperationConfig.STRATEGY_REGISTRY` нужно добавить новый элемент, например:

  ```python
  MetaOperationConfig.STRATEGY_REGISTRY.update({
      "base_signals_burst": BaseSignalsBurstStrategy
  })
  ```

  Ключ `"base_signals_burst"` станет именем стратегии в конфигурациях, а значение – ссылкой на класс реализации. Таким образом, детектор сможет создавать экземпляры этой стратегии по имени из конфигурации.

* **Настройки по умолчанию:** добавить **дефолтную конфигурацию** для новой стратегии в `MetaOperationConfig.DEFAULT_CONFIG` (или эквивалент). Например:

  ```python
  MetaOperationConfig.DEFAULT_CONFIG["base_signals_burst"] = {
      "window_ms": 100.0,
      "min_cluster_size": 2
  }
  ```

  Здесь `"window_ms": 100.0` задаёт окно времени в миллисекундах (100 мс по умолчанию). Параметр `"min_cluster_size": 2` можно включить для явного требования хотя бы 2 операций `base_signals` в группе (если это считается необходимым условием кластеризации). Если стратегия должна быть включена по умолчанию, можно неявно считать `enabled: True` (или добавить `"enabled": True` в конфиг для симметрии).

* **Включение/выключение стратегии:** обеспечить возможность отключить эвристику через конфигурацию. В структуре `META_OPERATION_CONFIG` (например, загружаемой из настроек приложения или определённой в коде) добавить раздел для данной стратегии. Например:

  ```python
  META_OPERATION_CONFIG = {
      "enabled": True,
      "strategies": {
          "base_signals_burst": {
              "enabled": True,
              "window_ms": 100,
              "min_cluster_size": 2
          },
          ...
      },
      "formatting": { ... }
  }
  ```

  Если флаг `"enabled"` для `base_signals_burst` выставить в `False`, `MetaOperationDetector` не должен применять эту стратегию. Реализация детектора обычно сама проверяет флаг и не инициализирует стратегию, если она отключена. Нужно убедиться, что данный механизм задействован: либо детектор читает `enabled` из конфига, либо стратегия в конструкторе может сама быстро выйти, если видит флаг отключения.

* **Приоритет применения:** при добавлении новой стратегии следует определить ее позицию в порядке приоритетов. Предположительно, **BaseSignalsBurstStrategy** имеет смысл запускать *раньше* общей стратегии по времени (TimeWindowStrategy) и стратегии по модулю (TargetClusterStrategy), чтобы специфичные кластеры `base_signals` выявлялись в первую очередь и “забирали” соответствующие подоперации. Порядок можно задать либо явно (если конфигурация позволяет указывать `priority` для стратегий), либо путем вставки стратегии в нужное место списка. Например, можно поместить ее с высоким приоритетом (1 или 2) перед другими, поскольку эта эвристика более специализирована.

* **Совместимость с архитектурой:** новая стратегия встроена модульно, не требуя изменения существующих классов, что соответствует принципу расширяемости системы. MetaOperationDetector должен просто получить дополнительный экземпляр стратегии в свой список и обработать его так же, как остальные. Это реализует **модульную архитектуру** агрегированного логирования, при которой добавление новых типов метрик или кластеризации не нарушает работу существующих компонентов.

## Вывод и форматирование результатов (OperationTableFormatter)

Для корректного отображения кластеров BaseSignalsMetaBurst в логах необходимо обеспечить поддержку этих мета-операций на уровне форматирования вывода, в частности в существующем классе **OperationTableFormatter** (или его улучшенной версии). Требования к выводу:

* **Единый блок в таблице:** Кластер мета-операции должен отображаться как **единая запись** (строка или сгруппированный блок) в отчёте, аналогично тому, как основная операция представляется в заголовке. Все операции, вошедшие в кластер, не должны перечисляться отдельно наравне с другими операциями – вместо этого они группируются внутрь этой мета-операции.

* **Свёрнутый список операций:** Операции внутри кластера по умолчанию **свернуты** – т.е. отображается только сводка/шапка мета-операции (с именем кластера и summary информацией). Детализированный список операций (включая их типы, статусы, время) может выводиться при выборе более подробного режима отображения.

* **Summary блока:** В конце вывода мета-операции можно отобразить её summary (описание), включающее число операций, время, и т.д., аналогично тому как выводится summary основной операции.

* **Совместимость режимов вывода:** Убедиться, что кластерная информация корректно отображается в разных форматах, поддерживаемых форматтером (табличный, компактный, подробный, JSON и т.д.).

## Соответствие архитектуре и расширяемость

Разработку **BaseSignalsMetaBurst** следует выполнить в полном соответствии с текущей архитектурой агрегированного логирования операций. Это означает:

* Стратегия реализована как **плагин** без изменения существующего кода захвата операций. MetaOperationDetector координирует её применение наряду с остальными эвристиками. Добавление BaseSignalsMetaBurst не должно нарушать основной поток логирования – кластеризация выполняется после сбора данных, в нежестком режиме (с отловом исключений, чтобы сбои в эвристике не влияли на основную операцию).
* Логика стратегии спроектирована **расширяемо**: в будущем её параметры (например, время окна, критерии кластеризации) могут легко меняться через конфиг, а также возможно добавление похожих стратегий для других модулей, по аналогии.
* Стратегия интегрируется с системой конфигурации **MetaOperationConfig** – все настройки централизованы и управляются единообразно. Администратор или разработчик сможет включить/выключить эвристику и настроить параметры без правки кода стратегии.
* Форматирование результатов не вводит жёстко запрограммированных особенностей именно под BaseSignalsMetaBurst, вместо этого использует уже заложенные механизмы отображения мета-операций.

В итоге, реализация **BaseSignalsMetaBurst** предоставит новый уровень детализации логирования для одиночных операций из модуля `base_signals.py`, позволив группировать пачки быстрых сигналов без вложенных подопераций в читаемые блоки. Это соответствует целям системы агрегированного логирования – повышать **читаемость** и **структурированность** логов без ущерба для производительности или целостности данных.
