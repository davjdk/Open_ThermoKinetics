Техническое задание: Переработка архитектуры обёртки логгера (logger_handler)
Цель
Переработать архитектуру системы логирования операций в Python‑проекте logger_handler для повышения прозрачности и удобства поддержки. Новая архитектура должна явно обозначать границы операций с помощью декоратора, автоматически собирать и отображать агрегированные метрики после выполнения каждой операции, а также устранить устаревший код. В результате должна получиться единая обёртка логгера (класс OperationLogger) с чистой реализацией, удовлетворяющей новым требованиям по агрегированию логов, обработке ошибок и настройке параметров времени.
Область изменений
Переработка затронет модуль логирования операций и связанные компоненты в проекте logger_handler. В частности, изменения коснутся следующих частей:
Класс обёртки логгера – обновление класса OperationLogger и связанных методов декорирования операций.
Определения операций – класс или перечисление OperationType, где перечислены все типы операций, будет использоваться для применения нового декоратора.
Механизм агрегирования – интеграция нового подхода агрегации логов (возможно, доработка OperationAggregator в явном режиме).
Формирование отчётной таблицы – логика построения ASCII-таблицы с метриками по операциям (включая использование существующего TabularFormatter или аналогичного инструмента).
Конфигурация – настройки приложения (например, в app_settings или конфигурационном классе) будут дополнены или скорректированы для задания временных параметров операций.
Устаревший код – удаление или переписывание всего кода, не необходимого для новой минималистичной реализации логгирования операций (например, старых механизмов автодетекции операций, дублей функциональности и т.п.).
Требования к функциональности
Новая версия обёртки логгера должна удовлетворять следующим функциональным требованиям:
Явное объявление операций через декоратор: Границы операций должны определяться явно при помощи декоратора @operation applied to the methods representing operations. Декоратор применяется над методами, соответствующими операциям из класса OperationType, и это должно быть организовано в одном месте в приложении (централизованно). То есть, вместо неявного перехвата логов, разработчики явно помечают методы операций декоратором @operation, обеспечивая единообразное логирование.
Автоматическое отображение агрегированных метрик: После выполнения каждого метода, обёрнутого декоратором @operation, система должна автоматически выводить в лог (или консоль) таблицу (ASCII-таблицу) с агрегированной информацией по выполненной операции. В этой таблице должны отображаться ключевые метрики, включая как минимум: количество вызовов данной операции (возможно с учётом вложенных вызовов), количество изменений в файлах (если операция производила запись/модификацию файлов), время выполнения операции и другие важные показатели производительности или результата. Формат таблицы – человекочитаемый, выровненный по столбцам; допускается использование уже имеющейся в проекте библиотеки для форматирования таблиц (например, класса TabularFormatter), чтобы не реализовывать форматирование с нуля.
Обработка ошибок операций: Если выполнение операции завершается с ошибкой (генерируется исключение внутри обёрнутого метода), то должна срабатывать специальная обработка. Необходимо предусмотреть компонент обработчика ошибок операций – определить интерфейс или базовый класс (например, OperationErrorHandler), который будет отвечать за обработку исключений, возникающих внутри операций. На этапе рефакторинга требуется только спроектировать и объявить такой интерфейс (методы, которые он должен содержать, например on_operation_error и т.п.), без реализации конкретной логики обработки. Обёртка OperationLogger при обнаружении ошибки должна фиксировать факт неуспеха (статус операции как "ERROR", сбор сообщения об ошибке) и вызывать обработчик ошибок (если он будет установлен впоследствии) в соответствии с объявленным интерфейсом.
Корректная работа с вложенными операциями: В случае, если одна операция вызывает другую (вложенные операции), новая архитектура не должна создавать отдельный объект/запись для каждой вложенной операции как самостоятельной. Вместо этого следует увеличивать счётчик вызовов в агрегированной таблице и учитывать метрики вложенной операции как часть родительской. Практически это означает, что если метод A, помеченный @operation, внутри себя вызывает метод B, тоже помеченный @operation, то в итоговой таблице для операции A количество вызовов будет включать вызов B, но отдельной новой записи для B не будет. Таким образом, вложенные вызовы агрегируются в рамках одной операции, сохраняя древовидную структуру логики, но представляясь единым сводным результатом. Это требование направлено на исключение дублирующей информации и чрезмерного разрастания логов при каскадных вызовах.
Настраиваемые временные рамки операций: Параметры времени, влияющие на агрегирование операций, должны задаваться через конфигурацию приложения. По умолчанию временное окно для группировки событий операции устанавливается равным 1 секунде. Это означает, например, что операции, запущенные почти одновременно или подряд в пределах 1 секунды, могут рассматриваться как единая последовательная операция (каскад) в агрегированном выводе. Данный порог должен быть настраиваемым – через параметр (например, operation_time_frame или использование существующего cascade_window в конфигурации) разработчики смогут изменить значение по необходимости. Также может быть предусмотрен тайм-аут длительности выполнения операции: если операция выполняется дольше заданного интервала, это может помечаться отдельно (например, флаг «долгая операция») – в рамках данного задания достаточно обеспечить наличие самого параметра и его использование при агрегировании.
Автоматическое применение обёртки ко всем операциям: Новая декораторная обёртка @operation должна применяться автоматически ко всем целевым методам, соответствующим операциям, перечисленным в app_settings.OperationType. Требуется спроектировать механизм, который исключит ситуацию, когда разработчик забудет вручную пометить новый метод. Например, возможно использование класс-декоратора или метакласса для класса OperationType (или класса, где реализованы методы операций) – при инициализации проходить по всем методам, относящимся к операциям, и оборачивать их декоратором. В итоге, для каждой константы/значения в OperationType соответствующий метод обработки должен быть под обёрткой @operation без необходимости вручной маркировки каждого. Это гарантирует единообразное логирование для всех операций, объявленных в системе.
Удаление лишнего кода: В процессе рефакторинга необходимо удалить или заменить весь устаревший, дублирующий или неиспользуемый код, который не является минимально необходимым для реализации логгирования операций по новой схеме. Любая логика, ранее использовавшаяся для агрегирования логов, которая теперь избыточна (например, сложные эвристики по обнаружению операций в тексте логов, старая реализация агрегаторов или сжатия данных, не востребованная в новом дизайне), должна быть исключена. Кодовая база после изменений должна содержать только актуальные компоненты для сбора и отображения агрегированной информации об операциях, без мёртвого кода и устаревших путей выполнения.
Ключевые компоненты
При реализации указанной функциональности участвуют следующие ключевые компоненты системы:
OperationLogger – основной класс-обёртка для логирования операций. Он сохранит своё текущее название и общую роль, но его внутренняя реализация будет переработана. В новом дизайне OperationLogger отвечает за: запуск и завершение операций (с фиксацией времени старта/окончания, статуса), ведение стека операций (с учётом вложенности), сбор пользовательских метрик и логирование важных событий. В него будет встроена логика автоматического отображения таблицы по завершении операции. Также OperationLogger будет интегрирован с новым интерфейсом обработчика ошибок – при ошибке внутри операции класс должен зафиксировать метрики ошибки и предоставить их обработчику (если таковой установлен).
Декоратор @operation – декоратор (реализуемый как метод или функция внутри logger_handler, возможно через OperationLogger.operation() или отдельную функцию, ссылающуюся на глобальный экземпляр логгера), используемый для пометки методов, представляющих бизнес-операции. Декоратор обеспечивает обёртывание вызова метода в контекст логирования: перед началом метода инициируется новая операция (OperationLogger.start_operation), а по завершении (успешном или с исключением) операция автоматически завершается (OperationLogger.end_operation) с записью статуса. Таким образом, любой метод, помеченный @operation, автоматически становится точкой агрегирования логов. Важно, что применение этого декоратора ко всем необходимым методам будет организовано централизованно (см. требование 6) – например, при определении класса с операциями декоратор сразу применяется ко всем нужным методам.
OperationType – класс (например, Enum или набор констант) в конфигурации приложения, перечисляющий все типы операций (например: ADD_REACTION, REMOVE_REACTION, LOAD_FILE, DECONVOLUTION и т.д.). Данный компонент используется как единый реестр операций, к которому привязана обёртка. Переработка предусматривает, что именно здесь в одном месте декоратор будет применён ко всем операциям: либо непосредственно через декорирование методов, принадлежащих OperationType, либо за счёт механизма, который по списку значений OperationType найдёт и обернёт соответствующие функции. Этот подход гарантирует, что список поддерживаемых операций и их логирование находятся в согласованности. Разработчикам необходимо будет добавить декоратор для новых операций, включённых в OperationType, либо воспользоваться автоматическим механизмом, чтобы новые операции не пропускались.
Интерфейс обработчика ошибок операций – новый абстрактный компонент, например класс OperationErrorHandler (название условное), определяющий методы для реакции на ошибки в операциях. Его можно оформить как протокол, абстрактный базовый класс или интерфейс с одним или несколькими методами (например, handle(error, operation_context)), вызываемыми OperationLogger при неуспешном завершении операции. На данном этапе реализации достаточно определить интерфейс (с документированием его предназначения), внедрить вызов обработчика в процессе завершения операции (если он задан), но не реализовывать конкретные подклассы. Этот компонент заложит основу для последующей обработки ошибок (например, откат изменений, пользовательские уведомления или логирование подробностей ошибок отдельно).
Модуль агрегирования операций – компонент, отвечающий за сбор и группировку информации об операциях. В текущем проекте эту роль частично выполняет класс OperationAggregator (с поддержкой “explicit mode” и “auto mode”). После рефакторинга акцент смещается на явный режим: OperationAggregator (если он остаётся в архитектуре) должен использоваться только во взаимодействии с OperationLogger. То есть, агрегатор будет стартовать и заканчивать операции по сигналам от обёртки (вызовы aggregator.start_operation() и aggregator.end_operation() происходят из OperationLogger для корневых операций). Весь функционал автоматического режима, когда агрегатор сам пытается обнаружить последовательность операций по шаблонам в логах, станет избыточным – его следует либо отключить, либо удалить. OperationAggregator в явном режиме будет собирать данные о каскадах операций и подготавливать их для вывода (например, суммировать счётчики вложенных операций, собирать дочерние операции в список и т.п.). Важно: при вложенных операциях агрегатор не должен создавать новую группу, а должен обновлять текущую (увеличивать счётчики), чтобы соответствовать требованию 4. Этот компонент может также следить за временем начала и конца операций, помогая реализовать временное окно (требование 5) – например, решать, что если между окончанием одной операции и началом следующей прошло менее 1 секунды, то их можно сгруппировать.
Вывод агрегированных данных (таблицы) – компонент для формирования таблиц ASCII с результатами операций. Вероятно, в проекте уже имеется класс для форматирования таблиц (например, TabularFormatter или OperationTableBuilder), которые можно использовать. В рамках новой архитектуры, после завершения операции (в OperationLogger.end_operation или аналогичном месте) следует сгенерировать структуру данных с метриками операции (название операции, общее число вызовов/подопераций, время выполнения, количество файлов, статус успех/ошибка, иные метрики, такие как число предупреждений, ошибок, пользовательские показатели и т.п.). Далее эта структура передаётся в компонент форматирования таблицы, который возвращает строковое представление в виде таблицы. Таблица должна содержать понятные заголовки столбцов (например: "Операция", "Кол-во вызовов", "Время, с", "Файлы", "Статус", ...). Если используются иерархические операции, может быть предусмотрен столбец "Под-операция" или вложенность строк с отступом для подопераций – по усмотрению разработчиков, как удобнее представить, но минимально можно ограничиться сводной строкой на всю операцию. Примечание: если библиотека TabularFormatter уже подключена и умеет форматировать определённые типы таблиц (например, тип operation_summary), следует её задействовать для единообразия стиля вывода.
Конфигурация (настройки) – используется для хранения параметров, влияющих на работу логгера. В данном случае нас интересуют настройки для временных рамок операций. Если в проекте уже есть OperationAggregationConfig с полем вроде cascade_window (предположительно, оно равнялось 1.0 секунды по умолчанию) – можно использовать его или аналогичный параметр. Также может потребоваться флаг включения/выключения агрегирования операций, однако по заданию агрегирование всегда активно для помеченных операций. Необходимо убедиться, что в конфигурации предусмотрен параметр времени (в секундах) для группировки операций и, при отсутствии, добавить его (DEFAULT_OPERATION_TIMEFRAME = 1.0 с возможностью изменения через настройки). Другой параметр – включение ASCII-таблиц. Если он есть (например, ascii_tables: True/False), убедиться, что он учитывается: при отключенном ASCII-формате вывод таблицы может быть упрощённым или вовсе подавлен.
Удаляемая логика
В ходе рефакторинга нужно устранить все элементы старой реализации, которые больше не понадобятся или будут противоречить новой архитектуре. К удаляемой или упрощаемой логике относятся:
Автоматическое обнаружение операций по логам: Если ранее OperationAggregator или другие компоненты пытались выявлять операции на основе шаблонов текстовых сообщений (например, парсинг строк логов на наличие упоминаний OperationType.XYZ или ключевых слов "OPERATION_START/END"), то эта функциональность должна быть удалена или отключена. В новой схеме все операции задаются явно декоратором, поэтому сложные регекс-шаблоны и эвристики для обнаружения последовательностей операций в необработанных логах больше не нужны. Код, связанный с auto_mode агрегатора (автоматическая агрегация без явных границ), подлежит удалению во избежание конфликтов и снижения сложности.
Устаревшие классы и функции для агрегации значений: Если в кодовой базе остались рудименты старых подходов (например, ранее существовавший класс ValueAggregator или функции, выполняющие схожую роль по сбору больших структур данных), которые теперь интегрированы внутрь OperationLogger, их следует убрать. Например, методы, дублирующие функциональность сжатия больших массивов/датасетов, или кэширования метрик, если они больше не используются напрямую, могут быть исключены. Все метрики теперь обрабатываются непосредственно через OperationLogger.add_metric с внутренней компрессией, поэтому отдельные модули для агрегации значений не требуются.
Дублирующая или мёртвая логика внутри логгера: Провести ревизию методов OperationLogger и связанного кода. Удалить любые методы, которые не используются или противоречат новым требованиям. Например, если были альтернативные способы инициировать логирование (контекст-менеджер, глобальные функции-обёртки) и они больше не нужны или могут запутывать, стоит оставить один консистентный способ. Код для сброса/рестарта логгера, если он не находит применения, можно убрать или упростить. Также удалить отладочные выводы, если таковые были временными.
Лишние настройки и флаги: В конфигурации отключить или удалить опции, которые касаются удалённого функционала. Например, если был флаг auto_mode_enabled для агрегатора – установить его по умолчанию в False или убрать использование. Аналогично, проверить флаги, связанные с низкоприоритетными таблицами, паттернами, и другими фичами, не относящимися к операциям (хотя они могут остаться для других частей системы, но убедиться, что они не препятствуют новой логике). Цель – минимизировать число путей выполнения: новая обёртка должна работать всегда при вызове помеченной операции, без разветвления на старый и новый механизм.
Неиспользуемый код обработки ошибок: Если в старом коде были попытки обрабатывать ошибки операций и они теперь заменяются новым обработчиком, тот старый код (например, какие-то try/except в вызывающем коде, делавшие собственный лог) можно удалить, доверив обработку централизованной обёртке. Аналогично, если существовали временные заглушки или нерабочие куски (например, всегда возвращающие успех), их нужно убрать или заменить реальной логикой сбора статуса операции.
В итоге, после очистки, кодовая база модуля logger_handler должна содержать только те части, которые используются для новой системы явного логирования операций. Удаление лишнего кода не только снизит сложность, но и упростит поддержку – разработчикам будет ясно, куда смотреть при необходимости доработать логирование.
Результат работы
По завершении рефакторинга архитектуры обёртки логгера должен получиться следующий результат:
Единая система явного логирования операций: Все методы, соответствующие операциям из OperationType, теперь обёрнуты декоратором @operation. При вызове любой такой операции автоматически фиксируется её начало и конец, а также подсчитываются метрики. Логи будут содержать структурированную информацию об операциях (начало, конец, длительность, и т.д.) без необходимости ручного вывода в каждом методе.
Агрегированная таблица после каждой операции: Пользователь или разработчик, наблюдая за выводом, будет видеть после выполнения каждой операции аккуратную ASCII-таблицу с суммарными данными. Например, сразу после выполнения операции "ADD_REACTION" можно увидеть таблицу, где указано, что операция Add Reaction была вызвана 1 раз (если были подоперации, здесь будет учтено их количество), сколько файлов затронуто (если применимо), общее время выполнения (скажем, 0.523 секунды), статус операции (✅ Успех или ❌ Ошибка), и прочие метрики (например, "Warnings: 0, Errors: 0" или доменные метрики вроде "Reactions found: N"). Такая таблица появляется автоматически, без дополнительных действий, что облегчает отладку и анализ производительности.
Корректное объединение вложенных операций: В логах и таблицах вложенные операции не раздуты в отдельные сущности. Если одна высокоуровневая операция запускает серию подопераций, в итоговом отчёте эта группа отображается как одна операция с увеличенным счётчиком вызовов и возможно списком под-операций в деталях. Разработчики смогут менять глубину детализации по желанию, но по умолчанию пользователь видит сводку на уровне верхней операции. Это упрощает восприятие результатов – вместо десятка строк об отдельных шагах, будет одна сводная запись (или таблица), показывающая совокупный эффект.
Индикация ошибок с возможностью расширения обработки: Если во время выполнения операции произошла ошибка, она не останется незамеченной. OperationLogger помечает такую операцию как неуспешную, собирает информацию об исключении (тип, сообщение) и включает её в метрики (например, выводит в таблицу столбец "Статус: Ошибка" и, возможно, краткое сообщение). Кроме того, архитектура готова к подключению кастомного обработчика: в коде определён интерфейс для обработки ошибок. Хотя конкретная реализация не входит в объём данного задания, наличие этого интерфейса означает, что в будущем можно легко подключить, например, логирование ошибок в отдельный файл, отображение всплывающих уведомлений для пользователя или откат транзакций – без изменения самой обёртки.
Гибкая настройка времени и параметров: В настройках приложения появится (или будет использован существующий) параметр, определяющий временной интервал группировки операций (по умолчанию 1 с). Результат рефакторинга гарантирует, что изменение этого параметра напрямую влияет на логику агрегирования: разработчики могут настроить его под характер нагрузок (например, увеличить, если операции должны группироваться в течение большего интервала). Это повышает адаптивность системы логирования. Также, если в конфигурации отключить вывод таблиц или задать альтернативный формат (через флаги), OperationLogger будет это уважать – например, можно отключить ASCII-таблицу для сокращения объёма логов в production, если это предусмотрено.
Чистый и поддерживаемый код: Код обёртки логгера станет значительно проще и понятнее. Уйдут сложные конструкции по парсингу логов и лишние прослойки. Останется чётко выделенный декоратор для операций и сопутствующие методы. Любой новый разработчик, изучающий logger_handler, сможет быстро понять, как добавлять новую операцию: достаточно включить её в OperationType и реализовать метод с таким же именем (или привязанным именем) под декоратором @operation. Логирование будет консистентным для всех операций. Удаление дублирующего/мертвого кода также снизит риск ошибок и облегчит модификацию системы в будущем (например, добавление новых метрик или изменения формата таблицы).
Ограничения и примечания
Сохранение имени класса: Класс обёртки должен по-прежнему называться OperationLogger, чтобы избежать каскадных изменений в кодовой базе. Внешний интерфейс использования (вызовы operation_logger = get_operation_logger() или декоратор @operation_logger.operation) желательно сохранить по возможности, обеспечив обратную совместимость. Это значит, что рефакторинг не должен требовать переписывания бизнес-логики, только её декорирования и настройки.
Использование готовых инструментов: Для формирования ASCII-таблиц не требуется изобретать собственный форматтер, если в проекте уже есть подходящий. Например, если имеется TabularFormatter или OperationTableBuilder, нужно задействовать их для вывода таблицы метрик операций. Это позволит выдержать единый стиль отображения и сэкономить время. Если такие инструменты отсутствуют, допускается подключить лёгкую библиотеку для ASCII-таблиц или написать простое форматирование вручную, но с соблюдением требований к читаемости (колонки выровнены по ширине, заголовки понятны).
Реализация автоматического декорирования: Механизм автоматического применения декоратора ко всем методам операций должен быть выполнен аккуратно, чтобы не повлиять на другие методы. Например, можно реализовать декоратор на уровне класса: при определении класса, содержащего методы-обработчики операций, в его __init_subclass__ проходить по атрибутам и оборачивать те, которые соответствуют элементам OperationType. Это должно быть прозрачно для вызывающей стороны. Необходимо учесть, что методы, не являющиеся операциями, не должны быть затронуты. Также убедиться, что декорирование не нарушит сигнатуры методов и работу сигналов (если, к примеру, эти методы связаны с PyQt @pyqtSlot, декоратор должен сохранять метаданные). В случае сложностей, допускается явно пометить методы декоратором в коде, но в одном месте – например, сразу при объявлении словаря обработчиков в одном модуле, чтобы было легко проверить полноту декорирования.
Временные рамки и таймауты: Порог в 1 секунду для группировки операций – значение по умолчанию. В документе требований это значение указано явно, но в коде оно должно быть задано через конфигурацию, чтобы легко менять. Если в системе предусмотрен общий таймаут на выполнение операции (например, чтобы помечать операции, работающие слишком долго), на данном этапе можно просто предусмотреть эту возможность (в виде параметра или метрики timeout_exceeded), но не обязательно реализовывать полную логику прерывания выполнения. Главное – структура должна позволять в будущем отреагировать, если операция длится более установленного времени (например, через OperationMonitor можно будет отметить статус TIMEOUT).
Thread-safety (потокобезопасность): Текущая реализация OperationLogger использует поток-локальные структуры (стек операций) для поддержки многопоточного вызова. При рефакторинге необходимо сохранить потокобезопасность: убедиться, что счетчики операций и контексты изолированы между потоками. Глобальный экземпляр OperationLogger может быть использован в разных потоках, поэтому использование threading.local() для хранения состояния (текущей операции) должно остаться, либо можно внедрить иной механизм, но обеспечивающий корректную работу в многопоточной среде. Все новые изменения (например, декоратор) должны быть совместимы с этим – обычно проблемы не возникает, так как декоратор просто вызывает OperationLogger методы, которые уже потокобезопасны.
Отсутствие реализации бизнес-логики в задании: Данное техническое задание фокусируется на инфраструктурных изменениях. Предполагается, что рефакторинг не изменит саму бизнес-логику операций, а только обёрнёт её новым логгером. Важно при реализации не нарушить поведение самих операций. Также, реализация обработчика ошибок откладывается – он только декларирован. Разработчикам нужно документировать этот интерфейс, чтобы другие знали, как его реализовать позже. Например, можно оставить комментарий типа "TODO: реализовать конкретный обработчик, имплементирующий OperationErrorHandler, для специфических нужд (отправка отчёта об ошибке и пр.)".
Проверка и тестирование: После внесения изменений необходимо протестировать несколько сценариев:
Успешное выполнение операции: удостовериться, что появляется корректная таблица с метриками.
Вложенные операции: например, операция A вызывает B – проверить, что в таблице A указан вызов B как часть A (счётчик или вложенная строка), и отдельной таблицы для B нет.
Ошибка в операции: намеренно выбросить исключение внутри операции и убедиться, что статус операции помечен как ошибочный, информация об ошибке добавлена (метрика или отдельная строка), и что сам вызов не приводит к необработанному исключению наружу (обёртка должна перехватывать его, логируя и перевыбрасывая или превращая в результат, в зависимости от требований приложения).
Конфигурация времени: изменить настройку временного окна на другое значение и повторить тест с несколькими операциями подряд, убедиться, что логика группировки/счётчиков меняется ожидаемым образом.
Эти проверки, хотя и выходят за рамки самого задания, важны для приёмки результата. Особое внимание следует уделить формату вывода – он должен быть удобочитаемым и соответствовать принятому стилю (например, использовать символы ✅/❌ для статусов, если они используются в других частях логов, единицы измерения для времени, и переводы на русский язык в тексте сообщений, если в остальном логирование локализовано).
Всем участникам разработки необходимо ознакомиться с настоящим техническим заданием. Реализацию следует вести с соблюдением данных требований, чтобы итоговая система логирования была целостной, понятной и удобной в поддержке. После внедрения изменений документировать получившуюся архитектуру (обновить внутренние Wiki/README, если нужно), особенно описание нового декоратора и примеры вывода таблиц, чтобы команда могла эффективно пользоваться новым функционалом.