# Техническое задание: Модуль кластеризации метаопераций для агрегированного логирования

## Введение и цель проекта

В системе агрегированного логирования операций требуются улучшения, направленные на повышение **читаемости** логов и выявление избыточных повторяющихся шагов в логике приложения. Достижение этой цели планируется через внедрение модуля кластеризации *метаопераций* – объединения множества единичных операций в более крупные логические группы. Такой подход позволит скрыть шум детализации, облегчить анализ выполнения, сохранив при этом полную **детализированную трассировку** для отладки. Модуль должен органично дополнить существующую архитектуру логирования, оставаясь компактным и модульным, чтобы соответствовать принципу **расширяемости** системы без существенных изменений существующего кода.


## 2. Основные требования
## Требования к решению

Модуль кластеризации метаопераций должен удовлетворять следующим требованиям:

1. **Компактность**: вывод мета-операции должен занимать минимум места, показывая лишь ключевые данные одной строкой с раскрытием по необходимости.
2. **Модульность**: алгоритмы детекции вынесены в плагины/стратегии, не затрагивающие бизнес-логику.
3. **Лёгкое удаление**: при отключении всех плагинов система должна вернуться к текущему поведению без изменений кода ядра.
4. **Расширяемость**: возможность добавлять новые эвристики (стратегии) динамически через конфиг или DI.
5. **Минимальность изменений**: вносить изменения лишь в слои `OperationLogger` и `AggregatedOperationLogger`, не затрагивая существующие `SubOperationLog` и вызовы `handle_request_cycle`.

## 3. Эвристики детекции (плагинная стратегия)

Каждая эвристика реализуется отдельным классом с интерфейсом:

```python
class MetaOpStrategy:
    def detect(self, prev: SubOperationLog, curr: SubOperationLog) -> bool:
        """Возвращает True, если две операции относятся к одной мета-операции"""
```

В конфиге указывается порядок и набор активных стратегий.

### 3.1 Кластеризация по времени (Главная эвристика)
Объединение операций, стартующих почти одновременно (в пределах настраиваемого окна, например 10–50 мс). Плагин должен обнаруживать группы шагов, временной интервал между началом которых меньше заданного порога, и помечать их как одну метаоперацию.
* Группировать операции, стартовавшие в пределах `time_window_ms` (по умолчанию 50–100 мс).
* Параметр: `time_window_ms: int`.

### 3.3 Схожесть имён операций
Кластеризация операций с похожими именами. Например, шаги, начинающиеся с общего префикса (`GET_*`, `LOAD_*`) или относящиеся к одному типу действия, могут рассматриваться как один логический блок. Плагин сравнивает `operation_name` операций и группирует последовательности однотипных вызовов.
* Операции с одинаковым префиксом или шаблоном (регулярным выражением).
* Параметр: `name_pattern: str` (regex).

### 3.4 Общие параметры запроса
Подоперации, направленные на одну и ту же подсистему/модуль (поле `target`, например `"file_data"`, `"series_data"` и т.д.) могут логически относиться к одному этапу работы. Плагин группирует последовательные вызовы с одинаковым `target`.
* Сравнивать ключи и значения в `request_kwargs`, группировать по совпадению.

### 3.5 Маршрут цели (target)

* Собирать операции с одинаковым `target`.

### 3.6 Счётчик подряд идущих шагов
Если встречается последовательность из N операций, исполненных без иных шагов между ними, они могут считаться единым метаблоком. Например, 3 шагов подряд, составляющих цикл или повторяющих действие, плагин может объединить в одну метаоперацию, чтобы отразить циклическую структуру. (Порог N задаётся конфигурацией.)
* Если подряд прошло ≥ `min_sequence` успешных или ошибочных, считать подпроцессом.
* Параметр: `min_sequence: int`.

### 3.9 Порог частоты вызовов

* Если количество вызовов одного типа > `freq_threshold` за `freq_window_ms`, помечать начало/конец.

## 4. Детекция мета-операций: примерная эвристика

На основании примера из логов:

* **Параметры**:

  * `batch_window_ms = 500`
  * `min_batch_size = 3`
  * `module_source = module.__class__.__name__`

* **Алгоритм**:

  1. При каждом вызове операции (в `OperationLogger.start_operation`) сохранять:

     * время старта
     * имя модуля-источника
  2. Сравнивать с предыдущей операцией:

     * если `(curr.time - prev.time) ≤ batch_window_ms` **и** `curr.module == prev.module` → инкрементировать счётчик внутри текущей группы
     * иначе — завершить текущую группу (если счётчик ≥ min\_batch\_size) и отрисовать её как мета-операцию, затем начать новую
  3. При завершении группы формировать блок:

     ```text
     Meta-operation "<ModuleName>_BATCH" – STARTED (id=N, YYYY-MM-DD HH:MM:SS)
       ├ Op1 – OK (t1 s)
       ├ Op2 – OK (t2 s)
       …
       └ OpK – OK (tK s)
     SUMMARY: steps K, successful K, total time T s.
     Meta-operation "<ModuleName>_BATCH" – COMPLETED (status: successful)
     ```

## 5. Изменения в коде

1. **OperationLogger**:

   * добавить хранение `prev_op` и `batch_state` в `thread-local`
   * в `complete_operation` проверять стратегию детекции и, при срабатывании, накапливать записи
   * метод `flush_batch()` для вывода и сброса текущей группы

2. **AggregatedOperationLogger**:

   * расширить `log_operation` поддержкой `MetaOperationLog` с новым форматом

3. **Конфигурация**:

   * файл `logger_config.py`: секция `meta_op` с параметрами `window_ms`, `min_size`, список стратегий (имён классов)
   * DI-контейнер или фабрика стратегий для загрузки по имени

4. **Тестирование**:

   * модульные тесты для каждой стратегии: по времени, по модулю, по имени
   * интеграционные тесты: реальный пример (см. логи id=21–28) должен свёртываться в одну мета-операцию

## 6. Документация и примеры

* Обновить `LOG_AGGREGATOR_ARCHITECTURE.md`, добавив раздел «Мета-операции» с диаграммой работы
* Добавить в `ARCHITECTURE.md` пример формирования батча на операции `SET_VALUE` → `UPDATE_VALUE` и т.

## Архитектурное решение

### Общий подход

Новый модуль будет реализован в виде компонента пост-обработки, который интегрируется в существующий процесс логирования **после** сбора данных операций, но **до** форматирования и вывода в файл. Согласно текущему жизненному циклу операции, после финализации операции на шаге 8 формируется форматированный лог и он отправляется в AggregatedOperationLogger для записи. Мы вставим этап кластеризации метаопераций между финализацией операции и форматированием лога. Это наиболее неинвазивная точка интеграции: вся информация о операциях уже собрана, но представление ещё не зафиксировано в тексте. Кроме того, такой подход не затрагивает перехват `handle_request_cycle`, декоратор `@operation` или сбор данных – он лишь обогащает их интерпретацию.

**Составные части решения:**

* **Интерфейс `MetaOperationDetector`:** Определяет контракт на обнаружение метаопераций. Будет представлен либо протоколом (абстрактным классом), либо набором требований к классу. Основной метод – `detect_meta_operations(operation_log: OperationLog) -> None`. Он принимает завершённый лог операции и выполняет кластеризацию его операций, помечая обнаруженные группы. Возвращаемое значение может быть None (изменения вносятся непосредственно в переданный `OperationLog`).

* **Плагины-эвристики (стратегии кластеризации):** Каждый плагин реализует определённый **интерфейс стратегии** – например, метод `detect(sub_op: SubOperationLog, context: OperationLog) -> Optional[str]`. Метод анализирует одну операцию (в контексте всей операции) и решает, относится ли она к какой-либо метаоперации. Если да, возвращает идентификатор метагруппы (например, строковый код или имя метаоперации), иначе – `None`. За каждым плагином закреплена своя логика (в соответствии с перечисленными эвристиками). Плагины будут самостоятельными классами, например `TimeWindowClusterDetector`, `ThreadClusterDetector`, `NameSimilarityDetector` и т.д.

* **Контейнер плагинов (менеджер стратегий):** Класс, реализующий интерфейс `MetaOperationDetector`, объединяющий несколько плагинов. Он хранит список активных стратегий и при вызове `detect_meta_operations` прогоняет переданный `OperationLog` через все стратегии. Контейнер отвечает за координацию: он может, например, инициализировать структуру для результирующих метаопераций, затем для каждой операции последовательно вызвать метод `detect` каждого плагина. Каждый плагин, обнаружив соответствие, помечает операцию определённым `meta_op_id`. Контейнер агрегирует результаты – группирует операции с одинаковыми `meta_op_id` в отдельные метаоперации. При необходимости, если разные плагины дали пересекающиеся группы, контейнер может применять приоритеты или объединять результаты (детальная политика может быть настроена — например, временная близость и одинаковый target могут образовать одну комбинированную группу).

* **Структура данных MetaOperation:** Для представления найденных кластеров вводится новая структура, например `MetaOperation` с полями: `meta_id: str` (уникальный идентификатор или имя группы), `sub_operations: List[SubOperationLog]` (список ссылок на операции, входящие в группу), `heuristic: str` (опционально, название стратегии, которая сформировала группу). Объекты MetaOperation логически интегрируются в `OperationLog` – например, в виде нового поля `meta_operations: List[MetaOperation]`. **Важно:** это добавление не ломает существующую логику, так как остальной код не зависит от нового поля. Сами списки операций в `OperationLog` остаются без изменений (оригинальный порядок и состав операций не нарушаются), метаоперации дополняют их, давая альтернативное представление.

**Минимальные изменения в существующем коде:**
Чтобы внедрить новый модуль, достаточно внести изменения в **одну точку**: на этапе вывода агрегированного лога. В частности, метод `AggregatedOperationLogger.log_operation()` будет вызывать детектор метаопераций перед форматированием. Например:

```python
class AggregatedOperationLogger:
    def log_operation(self, operation_log: OperationLog) -> None:
        # ... (существующая обработка)
        if META_DETECTOR_ENABLED:
            MetaOperationDetector.get_instance().detect_meta_operations(operation_log)
        formatted_log = self._formatter.format_operation_log(operation_log)
        self._aggregated_logger.info(formatted_log)
```

Таким образом, перед формированием текстового отчёта мы обогащаем `operation_log` информацией о метаоперациях. Этот шаг не изменяет сам механизм сбора, а лишь добавляет пост-обработчик. Такое расположение соответствует рекомендациям – **постобработка в AggregatedOperationLogger** без вмешательства в `OperationLogger` или интерцепторы. В случае, если по архитектурным соображениям нежелательно напрямую менять `AggregatedOperationLogger`, можно реализовать отдельный препроцессор: например, функцию-обёртку, вызываемую из `OperationLogger.complete_operation` перед передачей лога в AggregatedOperationLogger. Однако, изменение внутри `AggregatedOperationLogger` является более локальным и понятным решением.

### Интерфейсы и класс MetaOperationDetector

Для обеспечения модульности вводится абстракция **детектора метаопераций**. Ниже описаны ключевые интерфейсы (в псевдокоде Python):

* `class MetaOperationDetector`:

  * Метод `detect_meta_operations(log: OperationLog) -> None`: основной вход в модуль. Реализует контейнерную логику: итерируется по операциям `log.sub_operations` и применяет набор плагинов-стратегий. По результатам формирует структуры MetaOperation и связывает их с `OperationLog`.

* `class MetaOperationStrategy` (абстрактный базовый класс для плагинов):

  * Метод `detect(sub_op: SubOperationLog, context: OperationLog) -> Optional[str]`: определяет, относится ли данная операция `sub_op` (в контексте всей операции `context`) к некоторой метаоперации. Возвращает идентификатор метаоперации, если да, либо None. Идентификатор представляет собой условное имя группы. Например, реализация для временного окна может возвращать одинаковый ID для всех операций, лежащих внутри одного окна времени (ID может включать временную метку первого шага или порядковый номер группы).

Каждый конкретный плагин наследуется от `MetaOperationStrategy` и реализует метод `detect`. Для доступа к контексту плагин может анализировать другие операции из `context.sub_operations` (например, чтобы найти последовательные шаги или сравнить с предыдущими/следующими). **Важно:** Плагины не должны модифицировать состояние `OperationLog` напрямую – они лишь обнаруживают и помечают соответствия, например, через возвращаемые идентификаторы или установку пометки в объекте операции (можно временно добавить поле `meta_op_id` в `SubOperationLog` при обработке, которое затем используется контейнером для группировки). Однако, добавление поля в `SubOperationLog` следует делать аккуратно, чтобы не повлияло на сериализацию/вывод (в текущем форматировании дополнительные поля игнорируются). Лучше использовать внешнюю структуру (словарь соответствия или метки в контейнере) для временного хранения результатов детекции.

**Контейнер плагинов:** `MetaOperationDetector` содержит список активных стратегий, например `self.strategies: List[MetaOperationStrategy]`. Этот список настраивается через конфигурацию – например, можно определить в настройках логирования перечень имен стратегий, которые нужно задействовать. Контейнер при инициализации загружает соответствующие классы плагинов. Это даёт гибкость: чтобы отключить конкретную эвристику, достаточно убрать её из списка в конфигурации (или передать параметр, выключающий её). В рантайме также возможна динамическая активация/деактивация плагинов (например, для отладки или экспериментов), но основной сценарий – настройка через конфиг-файл или константу.

### Логика работы модульного детектора

При вызове `MetaOperationDetector.detect_meta_operations(operation_log)` выполняются следующие шаги:

1. **Инициализация:** Создаётся временный контейнер для обнаруженных групп (например, словарь `{meta_op_id: MetaOperation}`). Он изначально пуст.

2. **Перебор операций:** Последовательно анализируются `sub_op` из `operation_log.sub_operations` в порядке их исполнения (по возрастанию `step_number`). Для каждой операции:

   * Каждый плагин из списка `self.strategies` вызывается с параметрами `(sub_op, operation_log)`.
   * Если плагин возвращает `meta_op_id` (строку), значит, операция должна быть отнесена к группе с данным ID по данной стратегии. Например, `TimeWindowStrategy.detect` может вернуть `"time_cluster_1"` для группы тесно расположенных вызовов.
   * Контейнер собирает все такие идентификаторы. Если ни один плагин не вернул значение (т.е. None от всех), операция остаётся не сгруппированной (возможно одиночная или будет выведена как есть). Если один или несколько плагинов вернули *разные* идентификаторы, это означает, что операция удовлетворяет нескольким эвристикам (например, и по времени, и по target). В таких случаях возможны два подхода:

     * Разрешить множественное участие: операция включается в несколько метаопераций (пересекающиеся группы). Но при отображении это сложно, и может запутать чтение.
     * Использовать приоритеты или комбинацию: например, определить порядок плагинов и брать первый сработавший, игнорируя остальные для данной операции; либо объединять идентификаторы (менее предпочтительно).
   * В рамках ТЗ можно упростить: считать, что каждая операция может принадлежать не более чем одной метаоперации. При конфликте предпочтение отдаётся той эвристике, которая идёт первой в списке (порядок стратегий отражает важность). Эта политика должна быть описана в документации и при необходимости может быть изменена без затрагивания архитектуры.

3. **Формирование групп:** На основе идентификаторов, присвоенных операциям, контейнер группирует их. Например, если для sub\_op №2 и №3 получен `meta_op_id="time_cluster_1"`, а для sub\_op №4, №5 тот же ID, то группа `"time_cluster_1"` будет содержать операции 2-5. Для реализации можно:

   * Создавать/дополнять объект `MetaOperation` в словаре по ключу `meta_op_id`.
   * Добавлять ссылки на текущую sub\_op в список внутри соответствующего `MetaOperation`.

4. **Завершение:** Готовые объекты `MetaOperation` добавляются в `operation_log.meta_operations` (новое поле) или сохраняются иным способом внутри `OperationLog`. Например, `operation_log.meta_operations = list(meta_operations_dict.values())`. Также можно на уровне операций сохранить ссылку на их метагруппу (например, установить каждому `sub_op.meta_id = ...` для удобства форматирования, если решено добавлять поле). Однако, дублирование информации нежелательно – предпочтительнее хранить связь в одном месте (в структуре MetaOperation).

5. **Передача на форматирование:** После обогащения `operation_log` мета-информацией, управление возвращается в `AggregatedOperationLogger`, который вызовет форматирование через `OperationTableFormatter`. Далее лог будет записан обычным образом.

В результате этих действий в памяти `OperationLog` будет содержать дополнительный уровень группировки, не влияя на основной список операций (что важно для подсчётов и существующей статистики). Мы **не изменяем** и не удаляем сами `SubOperationLog` – они остаются доступными, просто теперь объединены логическими связками. Отметим, что всё происходит **после** финализации операции, то есть время выполнения и статусы всех операций уже зафиксированы и не изменятся.

### Форматирование и вывод с учётом метаопераций

Отдельным аспектом является представление кластеризованных метаопераций в конечном табличном логе. В текущей реализации `OperationTableFormatter` строит плоскую таблицу: колонками "Step", "Sub-operation", "Target", и т.д., построчно перечисляя все операции. После внедрения групп может потребоваться изменить способ вывода, чтобы визуально отразить кластеризацию:


* **Опциональность форматирования:** В требованиях указано, что визуальная группировка – опциональна. Это значит, что возможно на первом этапе модуль просто идентифицирует группы (чтобы аналитики могли их увидеть в сыром виде, например, через отладочный вывод или JSON-экспорт), а изменение собственно текстового лога может быть выполнено позднее или по флагу. Рекомендуется в `OperationTableFormatter` предусмотреть настройку, включающую или отключающую группировку при выводе. Например, флаг `group_meta_operations: bool` в конфигурации форматтера. Если он включён, форматтер использует информацию из `operation_log.meta_operations` для группировки строк. Если выключен – вывод остаётся в старом формате. Это позволит постепенно внедрить новую функциональность, не нарушая привычный формат логов для пользователей, до тех пор, пока группировка не будет отлажена и одобрена.

Для начальной реализации можно ограничиться простым подходом: например, выводить дополнительную колонку "MetaOp ID" для отладочных целей либо логировать группы отдельно после таблицы. Но конечная цель – **улучшение читаемости**, а значит нужно стремиться к интуитивному отображению групп прямо в таблице. Решение по форматированию должно быть согласовано с командой, ответственной за анализ логов, чтобы выбрать наиболее понятный способ (возможно, экспериментировать с макетом вывода).

## Интеграция и рекомендации по внедрению

**Точка подключения:** как отмечалось, лучшее место для интеграции – метод `AggregatedOperationLogger.log_operation` перед вызовом форматтера. Здесь у нас есть готовый объект `OperationLog` со всеми заполненными `sub_operations`. Вызывая `MetaOperationDetector.detect_meta_operations()` на нём, мы производим все необходимые группировки. После этого передаём обновлённый `OperationLog` в существующий форматтер. Ниже приведён фрагмент, демонстрирующий интеграцию (как рекомендация):

```python
# В aggregated_operation_logger.py
def log_operation(self, operation_log: OperationLog):
    if meta_detector is not None:
        meta_detector.detect_meta_operations(operation_log)
    formatted_log = self._formatter.format_operation_log(operation_log)
    ...
    self._aggregated_logger.info(formatted_log)
```

При таком подходе изменения в существующем коде минимальны: мы добавляем несколько строк в один метод. Вся новая логика инкапсулирована в модуле кластеризации. **OperationLogger** (декоратор, прокси и т.д.) остаются нетронутыми, работа их не меняется, что снижает риск регрессий. Это соответствует архитектурному требованию не модифицировать `OperationLogger`, декоратор `@operation` или `handle_request_cycle` напрямую.

**Конфигурация модулей:** Необходимо обеспечить гибкое включение/отключение функциональности. Например, в файле настроек логирования можно ввести параметр `ENABLE_META_CLUSTERING` и список активных стратегий `ENABLED_META_STRATEGIES = ["time_window", "target_match", ...]`. При инициализации `MetaOperationDetector` читает эти настройки и формирует соответствующий список плагинов. Если кластеризация отключена глобально, вызов `detect_meta_operations` можно пропускать совсем (или вернуть сразу). Если включена – но список стратегий пуст, модуль ничего не будет делать (на случай, если нужно запустить систему без ни одной эвристики). Такое проектирование через конфигурацию соответствует принципу **слабого связывания модулей**, декларированному в архитектуре проекта.

**Производительность:** Поскольку кластеризация выполняется синхронно при логировании, она должна работать эффективно. В худшем случае, если в одной операции сотни операций и множество эвристик, пост-обработка должна занимать незначительное время по сравнению с самой операцией. Этого можно достичь, например, предварительным вычислением вспомогательных структур (словарей по target, по именам, индексов по времени) для ускорения работы плагинов. Также важно избегать тяжелых операций в плагинах (например, сложных алгоритмов сравнения строк или больших по объёму вычислений), либо делать их ленивыми. Однако, учитывая что логирование уже подразумевает запись большого объёма данных, небольшое увеличение нагрузки приемлемо. Кроме того, можно реализовать асинхронный режим работы детектора: собирать OperationLog, помещать его в очередь на обработку и сразу отпускать основной поток, а кластеризацию и форматирование выполнять в фоновой задаче. Но для простоты MVP-реализации лучше начать с синхронной обработки в точке логирования.

**Тестирование и отладка:** Рекомендуется написать модульные тесты для каждого плагина, эмулирующие различные последовательности `SubOperationLog`. Например, для `TimeWindowStrategy` сгенерировать список операций с разными метками времени и проверить, что он правильно группирует только те, у которых разница < порога. Аналогично для `NameSimilarityStrategy` – подать список имён и проверить кластеризацию по префиксам. Контейнер `MetaOperationDetector` следует протестировать на комбинации стратегий и конфликтных случаях (когда одна операция может подходить под несколько критериев).

Также полезно временно включить вывод диагностической информации: например, после работы детектора, в отладочный лог (`logger.debug`) выводить сводку: сколько метаопераций найдено, какие операции в них входят. Это поможет убедиться, что модуль работает как ожидается, на реальных данных.

**Документация:** Поскольку система вводит новый уровень логирования, команде следует документировать новые понятия: что такое метаоперация, какие виды группировок реализованы, как они отображаются в логах. Пользователи (разработчики, аналитики) должны понять, что означает, например, выделенный блок в логе, почему определённые шаги скрыты под ним и как интерпретировать метаоперации. Возможно, стоит предоставить опцию отключения группировки при выводе (на случай, если нужен старый подробный вид для низкоуровневого анализа). Эта опция может быть той же `ENABLE_META_CLUSTERING` или отдельной для форматтера.

**Выявление избыточности:** Особо отметим, что одна из целей – нахождение избыточных действий. После внедрения кластеризации станет нагляднее видно, если приложение выполняет, скажем, 10 похожих запросов подряд (они свернутся в один блок с указанием количества). Это сигнал для разработчиков о возможности оптимизации. Рекомендуется в описании метаоперации (например, в заголовке блока) указывать суммарные характеристики: *что* сгруппировано и *сколько* раз. Например: `"► MetaOp: Повторяющийся вызов GET_VALUE (10 раз за 0.1с)"`. Такие описательные заголовки можно формировать в самом плагине (он знает критерий) и сохранять в объекте MetaOperation. Затем форматтер выведет их.

## Заключение

Данное техническое задание описывает модуль кластеризации метаопераций, призванный улучшить читаемость агрегированных логов и помочь в обнаружении лишних шагов в логике. Решение базируется на принципах модульности и расширяемости, принятых в проекте: новый функционал добавляется как независимый плагин, интегрированный через явный интерфейс, не нарушающий работы существующих компонентов логирования. Предложенная архитектура гарантирует слабое связывание – основная система взаимодействует с модулем через стандартный метод `detect_meta_operations`, не зная деталей реализации эвристик. Это соответствует подходу проектирования через расширяемые слои (extension points), указанному в манифесте архитектуры.

При реализации следует придерживаться минимализма в изменении существующего кода и тщательно протестировать работу новых компонентов. В результате команда разработки получит гибкий инструмент для группировки логов, который можно постепенно адаптировать под потребности анализа, включать новые виды эвристик и, в перспективе, позволить конечным пользователям системы настраивать уровень детализации логирования операций.
