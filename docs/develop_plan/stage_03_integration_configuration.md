# Этап 3: Интеграция и конфигурация

## Интеграция с существующей системой

Стратегия BaseSignalsMetaBurst должна быть интегрирована в существующий механизм детекции мета-операций с минимальными изменениями в общей архитектуре.

### Регистрация стратегии

В модуле `MetaOperationDetector` необходимо зарегистрировать новую стратегию. Существующая система инициализирует несколько стратегий на основе конфигурации (TimeWindowStrategy, TargetClusterStrategy и т.д.). Необходимо добавить логику, которая при включенной конфигурации `base_signals` создает экземпляр класса `BaseSignalsBurstStrategy` и добавляет его в список активных эвристик. Например:

```python
if config.strategies.get("base_signals_burst", {}).get("enabled"):
    strategy_config = config.strategies["base_signals_burst"]
    strategies.append(BaseSignalsBurstStrategy(strategy_config))
```

Тем самым `MetaOperationDetector.detect_meta_operations()` будет учитывать новую стратегию наряду с остальными.

### Порядок применения стратегий

Стратегия BaseSignalsMetaBurst не конфликтует напрямую с существующими, но потенциально может перекрывать некоторые случаи:

#### Взаимодействие с TimeWindowStrategy
**TimeWindowStrategy**: также группирует операции по времени, но без учета модуля. В ситуациях, когда burst из base_signals происходит в пределах 50-100 мс, TimeWindowStrategy тоже могла бы сгруппировать их (вместе с любыми другими). Теперь же BaseSignalsMetaBurst будет создавать более целевой кластер. Чтобы избежать дублирования кластеров, возможно, стоит либо дать BaseSignalsMetaBurst приоритет (например, запускать её раньше и помечать объединённые ею подоперации, чтобы другие стратегии их не трогали), либо научить TimeWindowStrategy пропускать операции `base_signals` (если такая оптимизация требуется).

#### Взаимодействие с другими стратегиями
**Другие стратегии**: TargetClusterStrategy (кластеризация по целевому модулю) не должна группировать base_signals операции, так как `target` у них, скорее всего, специфичен (например, сами base_signals могут вызывать разные цели). NameSimilarityStrategy, SequenceCountStrategy также маловероятно пересекаются, поскольку они не ориентированы на модуль. Тем не менее, интеграция новой стратегии должна быть протестирована совместно с остальными, чтобы один и тот же набор подопераций не оказался в двух разных MetaOperation.

### Взаимодействие с MetaOperationDetector

`MetaOperationDetector` отвечает за координацию стратегий и построение итоговых объектов мета-операций. После добавления BaseSignalsMetaBurst, его метод `detect_meta_operations(operation_log)` вызовет и её. Ожидается следующий механизм:

1. Detector проходит по списку `operation_log.sub_operations`. Для каждой подоперации последовательно применяет активные стратегии, вызывая их `detect(sub_op, operation_log)`.
2. Стратегия BaseSignalsMetaBurst для нерелевантных операций вернёт None (что означает "не кластеризовать"), а для релевантных может вернуть `meta_id`.
3. Detector собирает результаты: например, может использовать словарь `{meta_id -> список sub_op}`. Все подоперации, для которых вернулся одинаковый `meta_id = "base_signals_burst_X"`, попадают в один список.
4. После обработки всех подопераций Detector формирует для каждого ключа `meta_id` объект `MetaOperation` и наполняет его полями (как описано выше). Поле `heuristic` при этом устанавливается в `"BaseSignalsMetaBurst"` (название стратегии).
5. Готовый MetaOperation добавляется в `operation_log.meta_operations` (список мета-операций в структуре OperationLog).

### Форматирование и вывод

Форматтеры логов (например, `OperationTableFormatter`/`EnhancedTableFormatter`) должны отобразить новую мета-операцию. Согласно архитектуре, форматтеры знают о наличии мета-операций и режиме вывода. Проверим, что нужно для поддержки BaseSignalsMetaBurst:

#### Compact-режим (сжатый вывод)
В **compact-режиме** обычно отображается список обнаруженных кластеров сразу после заголовка операции. В примере логов показано, что выводится значок (например, ⚡) и строка вида `[meta_id] Name (N steps, T sec)`. Наша стратегия должна выводиться по аналогии, только вместо `Name` будет название кластера `"BaseSignals Burst"` (либо другое, сформированное описанием, потенциально содержащее актор и шум, как обсуждалось). Например:
`⚡ [base_signals_burst_162384] BaseSignals Burst (actor: user123, 3 steps, 0.089s, noise: 1)`

Если форматтер изначально не предусматривал вывод актора или шума, возможно, потребуется обновить шаблон форматирования кластеров: добавить опциональные части для этих данных.

#### Detailed-режим (подробный вывод)
В **detailed-режиме** обычно приводится таблица всех шагов с их деталями. В этой таблице мета-операции отображаются блоком: сначала строка с названием мета-кластера (отмеченная, напр., `>>> BaseSignals Burst (Meta-cluster)` аналогично примерам), а затем вложенные строки подопераций, принадлежащих этому кластеру, с отступом.

* Необходимо убедиться, что форматтер умеет брать `MetaOperation.sub_operations` и правильно их отображать сгруппированно.
* **Вопрос отображения шума**: так как шумовые операции не входят в `sub_operations` кластера, они появятся в общем списке подопераций как отдельные строки (вне групп). Форматтер мог бы отметить их специально, но на данном этапе достаточно, что в summary-кластере (строке `>>> ...`) указано наличие шума.

#### JSON-режим
Если система поддерживает вывод логов в JSON (для API), новый кластер появится как объект в списке `meta_operations` JSON-представления. В нём `heuristic` будет `"BaseSignalsMetaBurst"`, `meta_id` – наш сгенерированный, `sub_operations` – массив идентификаторов/описаний подопераций. При необходимости можно добавить поле `noise_count` (количество шумовых операций) в JSON, если формат логов допускает расширение.

### Неинвазивность интеграции

Интеграция стратегии не должна нарушить основной поток работы:

* Если при выполнении `BaseSignalsBurstStrategy.detect()` или формировании ее результата произойдёт ошибка, она должна быть перехвачена и залогирована, но не мешать основному логированию операции (это соответствует общему принципу meta-operation detection fail-safe).
* При отключенной стратегии (флаг `enabled: False` в конфигурации) код инициализации всё равно должен быть устойчивым: либо стратегия не создается вовсе, либо `detect` сразу ничего не делает. Таким образом, отключение полностью убирает эффект BaseSignalsMetaBurst, сохраняя поведение системы как было до её внедрения.

## Конфигурация

Настройки для новой стратегии будут добавлены в общий словарь конфигурации мета-операций (`META_OPERATION_CONFIG`), рядом с другими стратегиями. В файле `meta_operation_config.py` это, вероятно, секция `strategies`. Например:

```python
META_OPERATION_CONFIG = {
    "enabled": True,
    "strategies": {
        "time_window": { ... },
        "target_cluster": { ... },
        "name_similarity": { ... },
        "sequence_count": { ... },
        "base_signals_burst": {
            "enabled": True,
            "window_ms": 100,
            "min_cluster_size": 2
        }
    },
    "formatting": {
        "mode": "compact",
        "show_individual_operations": True,
        "meta_operation_summary": True
    }
}
```

### Параметры конфигурации

В этом примере для стратегии BaseSignalsMetaBurst введён ключ `"base_signals_burst"`:

* **`"enabled": True`** включает стратегию (если нужно временно отключить – ставится False, либо весь блок убирается).
* **`"window_ms": 100`** задаёт размер временного окна в миллисекундах (по умолчанию 100, но может быть изменено для чувствительности детекции). Название параметра может быть `"window_ms"` или `"time_window_ms"` – важно обеспечить соответствие между именем в конфиге и тем, что ожидает `validate_config` стратегии.
* **`"min_cluster_size": 2`** – минимальное число операций для формирования мета-операции. Этот параметр опционален; если не указан, по умолчанию стратегия будет требовать >=2 операций. Администратор может увеличить это значение, если, например, хочет кластеризовать только более крупные bursts (например, 3 и более операций).

### Дополнительные параметры
Возможны дополнительные параметры в будущем (например, `"actor_field"` – имя поля в OperationLog, откуда брать актор, если вдруг нужно сконфигурировать; или `"label_noise": True/False` для управления выводом шума), но на данный момент перечисленных достаточно.

### Управление конфигурацией

После изменения конфигурации, система при инициализации прочитает этот словарь. `MetaOperationConfig` в центральной конфигурации агрегатора должен быть расширен, чтобы распознавать новый ключ. Судя по архитектуре, MetaOperationConfig хранит централизованные настройки всех стратегий, так что новое поле впишется естественным образом. Также общий флаг `"enabled": True/False` контролирует включение системы кластеризации в целом – если он False, то никакие стратегии, включая нашу, не запускаются.

### Требования к управляемости

Важно упомянуть, что стратегия **BaseSignalsMetaBurst должна быть полностью управляемой конфигурацией**:

* При выключенном блоке или флаге она не участвует в процессе (мета-операции base_signals не формируются вовсе).
* Изменение параметров (окна, размера кластера) влияет на детекцию без необходимости менять код.
* Конфигурация должна быть документирована для пользователей системы: добавить описание новой опции в файл настроек (в комментариях или документации).

## Цели этапа

1. **Определить механизмы регистрации** - как стратегия подключается к системе
2. **Спроектировать взаимодействие с существующими стратегиями** - избежание конфликтов
3. **Определить конфигурационные параметры** - все настройки стратегии
4. **Спроектировать интеграцию с форматтерами** - поддержка всех режимов вывода
5. **Обеспечить неинвазивность** - минимальные изменения в существующем коде

## Результаты этапа

- [ ] Определен механизм регистрации в MetaOperationDetector
- [ ] Спроектировано взаимодействие с существующими стратегиями
- [ ] Создана структура конфигурации для BaseSignalsMetaBurst
- [ ] Определена интеграция с форматтерами логов  
- [ ] Обеспечена полная отключаемость через конфигурацию
- [ ] Документированы требования к неинвазивности
- [ ] Создан план обратной совместимости

## Следующий этап

**Этап 4: Примеры и сценарии использования** - разработка конкретных примеров работы стратегии и ожидаемых результатов.
