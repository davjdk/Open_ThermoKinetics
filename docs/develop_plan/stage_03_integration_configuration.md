# Этап 3: Интеграция и конфигурация

## Интеграция с существующей системой

Стратегия BaseSignalsMetaBurst должна быть интегрирована в существующий механизм детекции мета-операций с минимальными изменениями в общей архитектуре.

### Регистрация стратегии

В модуле `MetaOperationDetector` необходимо зарегистрировать новую стратегию. Существующая система инициализирует несколько стратегий на основе конфигурации (TimeWindowStrategy, TargetClusterStrategy и т.д.). Необходимо добавить логику, которая при включенной конфигурации `base_signals` создает экземпляр класса `BaseSignalsBurstStrategy` и добавляет его в список активных эвристик. Например:

```python
if config.strategies.get("base_signals_burst", {}).get("enabled"):
    strategy_config = config.strategies["base_signals_burst"]
    strategies.append(BaseSignalsBurstStrategy(strategy_config))
```

Тем самым `MetaOperationDetector.detect_meta_operations()` будет учитывать новую стратегию наряду с остальными.

### Порядок применения стратегий

Стратегия BaseSignalsMetaBurst не конфликтует напрямую с существующими, но потенциально может перекрывать некоторые случаи:

#### Взаимодействие с TimeWindowStrategy
**TimeWindowStrategy**: также группирует операции по времени, но без учета модуля. В ситуациях, когда burst из base_signals происходит в пределах 50-100 мс, TimeWindowStrategy тоже могла бы сгруппировать их (вместе с любыми другими). Теперь же BaseSignalsMetaBurst будет создавать более целевой кластер. Чтобы избежать дублирования кластеров, возможно, стоит либо дать BaseSignalsMetaBurst приоритет (например, запускать её раньше и помечать объединённые ею подоперации, чтобы другие стратегии их не трогали), либо научить TimeWindowStrategy пропускать операции `base_signals` (если такая оптимизация требуется).

#### Взаимодействие с другими стратегиями
**Другие стратегии**: TargetClusterStrategy (кластеризация по целевому модулю) не должна группировать base_signals операции, так как `target` у них, скорее всего, специфичен (например, сами base_signals могут вызывать разные цели). NameSimilarityStrategy, SequenceCountStrategy также маловероятно пересекаются, поскольку они не ориентированы на модуль. Тем не менее, интеграция новой стратегии должна быть протестирована совместно с остальными, чтобы один и тот же набор подопераций не оказался в двух разных MetaOperation.

### Взаимодействие с MetaOperationDetector

`MetaOperationDetector` отвечает за координацию стратегий и построение итоговых объектов мета-операций. После добавления BaseSignalsMetaBurst, его метод `detect_meta_operations(operation_log)` вызовет и её. Ожидается следующий механизм:

1. Detector проходит по списку `operation_log.sub_operations`. Для каждой подоперации последовательно применяет активные стратегии, вызывая их `detect(sub_op, operation_log)`.
2. Стратегия BaseSignalsMetaBurst для нерелевантных операций вернёт None (что означает "не кластеризовать"), а для релевантных может вернуть `meta_id`.
3. Detector собирает результаты: например, может использовать словарь `{meta_id -> список sub_op}`. Все подоперации, для которых вернулся одинаковый `meta_id = "base_signals_burst_X"`, попадают в один список.
4. После обработки всех подопераций Detector формирует для каждого ключа `meta_id` объект `MetaOperation` и наполняет его полями (как описано выше). Поле `heuristic` при этом устанавливается в `"BaseSignalsMetaBurst"` (название стратегии).
5. Готовый MetaOperation добавляется в `operation_log.meta_operations` (список мета-операций в структуре OperationLog).

### Форматирование и вывод

Форматтеры логов (например, `OperationTableFormatter`/`EnhancedTableFormatter`) должны отобразить новую мета-операцию. Согласно архитектуре, форматтеры знают о наличии мета-операций и режиме вывода. Проверим, что нужно для поддержки BaseSignalsMetaBurst:

#### Compact-режим (сжатый вывод)
В **compact-режиме** обычно отображается список обнаруженных кластеров сразу после заголовка операции. В примере логов показано, что выводится значок (например, ⚡) и строка вида `[meta_id] Name (N steps, T sec)`. Наша стратегия должна выводиться по аналогии, только вместо `Name` будет название кластера `"BaseSignals Burst"` (либо другое, сформированное описанием, потенциально содержащее актор и шум, как обсуждалось). Например:
`⚡ [base_signals_burst_162384] BaseSignals Burst (actor: user123, 3 steps, 0.089s, noise: 1)`

Если форматтер изначально не предусматривал вывод актора или шума, возможно, потребуется обновить шаблон форматирования кластеров: добавить опциональные части для этих данных.

#### Detailed-режим (подробный вывод)
В **detailed-режиме** обычно приводится таблица всех шагов с их деталями. В этой таблице мета-операции отображаются блоком: сначала строка с названием мета-кластера (отмеченная, напр., `>>> BaseSignals Burst (Meta-cluster)` аналогично примерам), а затем вложенные строки подопераций, принадлежащих этому кластеру, с отступом.

* Необходимо убедиться, что форматтер умеет брать `MetaOperation.sub_operations` и правильно их отображать сгруппированно.
* **Вопрос отображения шума**: так как шумовые операции не входят в `sub_operations` кластера, они появятся в общем списке подопераций как отдельные строки (вне групп). Форматтер мог бы отметить их специально, но на данном этапе достаточно, что в summary-кластере (строке `>>> ...`) указано наличие шума.

#### JSON-режим
Если система поддерживает вывод логов в JSON (для API), новый кластер появится как объект в списке `meta_operations` JSON-представления. В нём `heuristic` будет `"BaseSignalsMetaBurst"`, `meta_id` – наш сгенерированный, `sub_operations` – массив идентификаторов/описаний подопераций. При необходимости можно добавить поле `noise_count` (количество шумовых операций) в JSON, если формат логов допускает расширение.

### Неинвазивность интеграции

Интеграция стратегии не должна нарушить основной поток работы:

* Если при выполнении `BaseSignalsBurstStrategy.detect()` или формировании ее результата произойдёт ошибка, она должна быть перехвачена и залогирована, но не мешать основному логированию операции (это соответствует общему принципу meta-operation detection fail-safe).
* При отключенной стратегии (флаг `enabled: False` в конфигурации) код инициализации всё равно должен быть устойчивым: либо стратегия не создается вовсе, либо `detect` сразу ничего не делает. Таким образом, отключение полностью убирает эффект BaseSignalsMetaBurst, сохраняя поведение системы как было до её внедрения.

## Конфигурация

Настройки для новой стратегии будут добавлены в общий словарь конфигурации мета-операций (`META_OPERATION_CONFIG`), рядом с другими стратегиями. В файле `meta_operation_config.py` это, вероятно, секция `strategies`. Например:

```python
META_OPERATION_CONFIG = {
    "enabled": True,
    "strategies": {
        "time_window": { ... },
        "target_cluster": { ... },
        "name_similarity": { ... },
        "sequence_count": { ... },
        "base_signals_burst": {
            "enabled": True,
            "window_ms": 100,
            "min_cluster_size": 2
        }
    },
    "formatting": {
        "mode": "compact",
        "show_individual_operations": True,
        "meta_operation_summary": True
    }
}
```

### Параметры конфигурации

В этом примере для стратегии BaseSignalsMetaBurst введён ключ `"base_signals_burst"`:

* **`"enabled": True`** включает стратегию (если нужно временно отключить – ставится False, либо весь блок убирается).
* **`"window_ms": 100`** задаёт размер временного окна в миллисекундах (по умолчанию 100, но может быть изменено для чувствительности детекции). Название параметра может быть `"window_ms"` или `"time_window_ms"` – важно обеспечить соответствие между именем в конфиге и тем, что ожидает `validate_config` стратегии.
* **`"min_cluster_size": 2`** – минимальное число операций для формирования мета-операции. Этот параметр опционален; если не указан, по умолчанию стратегия будет требовать >=2 операций. Администратор может увеличить это значение, если, например, хочет кластеризовать только более крупные bursts (например, 3 и более операций).

### Дополнительные параметры
Возможны дополнительные параметры в будущем (например, `"actor_field"` – имя поля в OperationLog, откуда брать актор, если вдруг нужно сконфигурировать; или `"label_noise": True/False` для управления выводом шума), но на данный момент перечисленных достаточно.

### Управление конфигурацией

После изменения конфигурации, система при инициализации прочитает этот словарь. `MetaOperationConfig` в центральной конфигурации агрегатора должен быть расширен, чтобы распознавать новый ключ. Судя по архитектуре, MetaOperationConfig хранит централизованные настройки всех стратегий, так что новое поле впишется естественным образом. Также общий флаг `"enabled": True/False` контролирует включение системы кластеризации в целом – если он False, то никакие стратегии, включая нашу, не запускаются.

### Требования к управляемости

Важно упомянуть, что стратегия **BaseSignalsMetaBurst должна быть полностью управляемой конфигурацией**:

* При выключенном блоке или флаге она не участвует в процессе (мета-операции base_signals не формируются вовсе).
* Изменение параметров (окна, размера кластера) влияет на детекцию без необходимости менять код.
* Конфигурация должна быть документирована для пользователей системы: добавить описание новой опции в файл настроек (в комментариях или документации).

## Цели этапа

1. **Определить механизмы регистрации** - как стратегия подключается к системе
2. **Спроектировать взаимодействие с существующими стратегиями** - избежание конфликтов
3. **Определить конфигурационные параметры** - все настройки стратегии
4. **Спроектировать интеграцию с форматтерами** - поддержка всех режимов вывода
5. **Обеспечить неинвазивность** - минимальные изменения в существующем коде

## Детальная интеграция с MetaOperationConfig

### Расширение STRATEGY_REGISTRY

В файле `meta_operation_config.py` необходимо добавить новую стратегию в реестр:

```python
from .detection_strategies import (
    BaseSignalsBurstStrategy,  # Новый импорт
    NameSimilarityStrategy,
    SequenceCountStrategy, 
    TargetClusterStrategy,
    TimeWindowStrategy,
)

class MetaOperationConfig:
    STRATEGY_REGISTRY: Dict[str, Type[MetaOperationStrategy]] = {
        "time_window": TimeWindowStrategy,
        "name_similarity": NameSimilarityStrategy,
        "target_cluster": TargetClusterStrategy,
        "sequence_count": SequenceCountStrategy,
        "base_signals_burst": BaseSignalsBurstStrategy,  # Новая регистрация
    }
```

### Расширение DEFAULT_CONFIG

Добавление конфигурации по умолчанию для новой стратегии:

```python
DEFAULT_CONFIG: Dict[str, Dict[str, Any]] = {
    "time_window": {
        "window_ms": 50.0,
        "min_cluster_size": 2,
    },
    # ... существующие стратегии ...
    "base_signals_burst": {
        "window_ms": 100.0,
        "min_cluster_size": 2,
        "actor_threshold": 3,  # Минимум операций для выделения актора
        "noise_tolerance": 1,  # Максимум шумовых операций в burst
    },
}
```

### Интеграция в предустановленные конфигурации

Добавление стратегии в preset-конфигурации для различных сценариев использования:

```python
PRESET_CONFIGS = {
    # ... существующие конфигурации ...
    "base_signals_focused": {
        "strategies": [
            {
                "name": "base_signals_burst",
                "priority": 1,
                "params": {
                    "window_ms": 80,
                    "min_cluster_size": 2,
                    "actor_threshold": 2,
                    "noise_tolerance": 2,
                },
            },
            {
                "name": "time_window", 
                "priority": 2,
                "params": {
                    "window_ms": 50,
                },
            },
        ]
    },
    "enhanced_clustering": {
        "strategies": [
            {
                "name": "time_window",
                "priority": 1,
                "params": {"window_ms": 50},
            },
            {
                "name": "base_signals_burst",  # Добавление в существующую конфигурацию
                "priority": 2,
                "params": {
                    "window_ms": 100,
                    "min_cluster_size": 2,
                },
            },
            {
                "name": "target_cluster",
                "priority": 3,
                "params": {
                    "target_list": ["file_data", "series_data", "calculation_data"],
                    "max_gap": 1,
                    "strict_sequence": False,
                    "min_cluster_size": 2,
                },
            },
            # ... остальные стратегии ...
        ]
    },
}
```

## План интеграционного тестирования

### Тестирование изоляции стратегии

**Тест 1: Независимая работа**
- Создать operation_log только с base_signals операциями
- Убедиться, что BaseSignalsBurstStrategy корректно их кластеризует
- Проверить, что другие стратегии не влияют на результат

**Тест 2: Приоритетность обнаружения**
- Создать смешанный operation_log с base_signals и другими операциями
- Настроить приоритет BaseSignalsBurstStrategy = 1
- Убедиться, что base_signals операции захватываются именно этой стратегией

**Тест 3: Взаимодействие с TimeWindowStrategy**
- Создать операции base_signals в временном окне 50ms
- Проверить, что при разных приоритетах стратегий результат корректен
- Убедиться в отсутствии дублирования мета-операций

### Тестирование конфигурации

**Тест 4: Отключение стратегии**
```python
config = {
    "strategies": [
        {
            "name": "base_signals_burst",
            "priority": 1, 
            "params": {"enabled": False}  # Отключена
        }
    ]
}
# Убедиться, что мета-операции base_signals не создаются
```

**Тест 5: Параметризованная конфигурация**
- Протестировать различные значения window_ms (50, 100, 200ms)
- Протестировать min_cluster_size (1, 2, 3, 5)
- Убедиться в корректной валидации параметров

**Тест 6: Preset-конфигурации**
- Создать детектор через каждую preset-конфигурацию
- Проверить корректность инициализации BaseSignalsBurstStrategy
- Протестировать работу в составе multiple-strategy configurations

### Тестирование обратной совместимости

**Тест 7: Старые конфигурации**
- Загрузить конфигурации без base_signals_burst стратегии
- Убедиться, что система работает как раньше
- Проверить отсутствие ошибок инициализации

**Тест 8: Форматирование логов**
- Протестировать все режимы вывода (compact, detailed, table, json)
- Убедиться в корректном отображении base_signals мета-операций
- Проверить backward compatibility форматтеров

## Обратная совместимость

### Принципы совместимости

1. **Неинвазивность**: Существующий код работает без изменений при отключенной стратегии
2. **Опциональность**: Стратегия активируется только при явном включении в конфигурации
3. **Graceful degradation**: Ошибки в новой стратегии не влияют на основную функциональность
4. **API-стабильность**: Не изменяются существующие интерфейсы и методы

### Гарантии совместимости

**Конфигурационная совместимость**:
- Старые конфигурации работают без base_signals_burst секции
- Новые параметры имеют разумные значения по умолчанию
- Неизвестные параметры игнорируются с предупреждением

**Форматирование логов**:
- Существующие форматтеры поддерживают новые мета-операции автоматически
- Режимы вывода (compact/detailed) не изменяют поведение для других стратегий
- JSON-формат расширяется только новыми полями (без breaking changes)

**Runtime-совместимость**:
- AggregatedOperationLogger работает с/без новой стратегии
- MetaOperationDetector корректно обрабатывает пустой список стратегий
- Валидация конфигурации fail-safe для новых параметров

### Миграционный план

**Фаза 1**: Добавление стратегии в отключенном состоянии
- Добавить BaseSignalsBurstStrategy в STRATEGY_REGISTRY
- Все preset-конфигурации не включают новую стратегию
- DEFAULT_CONFIG содержит параметры с enabled: false

**Фаза 2**: Опциональное включение
- Документировать новую стратегию в руководстве пользователя
- Добавить base_signals_burst в одну из preset-конфигураций (например, "experimental")
- Провести тестирование в production-like окружении

**Фаза 3**: Полная интеграция
- Включить стратегию в стандартные preset-конфигурации
- Обновить документацию с примерами использования
- Мониторинг производительности и качества детекции

## План интеграционного тестирования

### Автоматизированные тесты

**test_base_signals_integration.py**:
```python
def test_strategy_registration():
    """Тест регистрации стратегии в MetaOperationConfig"""
    assert "base_signals_burst" in MetaOperationConfig.STRATEGY_REGISTRY
    
def test_detector_creation_with_base_signals():
    """Тест создания детектора с base_signals стратегией"""
    config = MetaOperationConfig(preset="base_signals_focused")
    detector = config.create_detector()
    strategy_names = [s.strategy_name for s in detector.strategies]
    assert "BaseSignalsBurst" in strategy_names

def test_interaction_with_time_window():
    """Тест взаимодействия с TimeWindowStrategy"""
    # Создать операции, подходящие под обе стратегии
    # Проверить приоритетность обработки
    pass

def test_backward_compatibility():
    """Тест обратной совместимости"""
    # Протестировать старые конфигурации
    # Убедиться в отсутствии breaking changes
    pass
```

### Интеграционные тесты

**test_meta_operation_integration.py**:
```python
def test_end_to_end_base_signals_detection():
    """End-to-end тест детекции base_signals мета-операций"""
    # Создать реальный OperationLog с base_signals операциями
    # Применить полный pipeline детекции
    # Проверить корректность результирующих MetaOperation
    pass

def test_formatter_integration():
    """Тест интеграции с форматтерами логов"""
    # Создать мета-операции с base_signals
    # Протестировать все форматтеры (compact, detailed, json)
    # Проверить корректность вывода
    pass
```

## Результаты этапа

- [x] Определен механизм регистрации в MetaOperationDetector
- [x] Спроектировано взаимодействие с существующими стратегиями
- [x] Создана структура конфигурации для BaseSignalsMetaBurst
- [x] Определена интеграция с форматтерами логов  
- [x] Обеспечена полная отключаемость через конфигурацию
- [x] Документированы требования к неинвазивности
- [x] Создан план обратной совместимости
- [x] Разработан план интеграционного тестирования
- [x] Определены preset-конфигурации для различных сценариев
- [x] Спроектирован миграционный план поэтапного внедрения

## Следующий этап

**Этап 4: Примеры и сценарии использования** - разработка конкретных примеров работы стратегии и ожидаемых результатов.
