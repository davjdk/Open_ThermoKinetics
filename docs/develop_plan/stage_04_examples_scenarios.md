# Этап 4: Примеры и сценарии использования

## Примеры работы стратегии BaseSignalsMetaBurst

Рассмотрим пример работы стратегии **BaseSignalsMetaBurst** в контексте одной бизнес-операции. Предположим, OperationLog содержит следующий набор подопераций (для наглядности укажем модуль и время начала каждой подоперации):

### Исходные данные для примера

1. **SubOp1:** `operation_name="SignalA"`, `source_module="base_signals"`, start_time = 12.000 (секунд), end_time = 12.010.
2. **SubOp2:** `operation_name="SignalB"`, `source_module="base_signals"`, start_time = 12.040, end_time = 12.050.
3. **SubOp3:** `operation_name="ValidateData"`, `source_module="validation"`, start_time = 12.055, end_time = 12.058.
4. **SubOp4:** `operation_name="SignalC"`, `source_module="base_signals"`, start_time = 12.095, end_time = 12.100.
5. **SubOp5:** `operation_name="DBCommit"`, `source_module="database"`, start_time = 12.500, end_time = 12.510.

### Пояснения к сценарию

Три сигнальных операции (SignalA, SignalB, SignalC) инициированы модулем base_signals и происходят практически подряд, в интервале от 12.000 до 12.100 (100 миллисекунд). Между ними затесалась небольшая операция ValidateData от модуля validation (№3). Позже, в той же бизнес-операции, произошла еще одна операция DBCommit (№5) значительно позже (в 12.5 секундах), не связанная по времени с сигналами.

### Ожидаемое поведение стратегии

* Подоперации 1, 2 и 4 (`base_signals`) будут распознаны как единый кластер, так как их времена начала находятся в пределах окна 100 мс друг от друга (от 12.000 до 12.095 ~ 95 мс). Подоперация 5 отстоит от них на 400 мс, она не попадёт в кластер.
* Стратегия пренебрежёт подоперацией 3 (ValidateData) при определении кластера, поскольку она не из base_signals. Однако, её **наличие между SignalB и SignalC** будет отмечено как шум: она началась в 12.055, то есть внутри интервала [12.000, 12.100] кластера.
* Таким образом, стратегия сформирует один MetaOperation:
  * `meta_id: "base_signals_burst_12000"` (примерно, взяв время первой операции 12.000s = 12000 мс; точный формат может различаться).
  * `heuristic: "BaseSignalsMetaBurst"`.
  * `sub_operations`: ссылки на SubOp1, SubOp2, SubOp4 (три операции base_signals).
  * `cluster_start_time = 12.000`, `cluster_end_time = 12.100`, `total_execution_time = 0.100` сек (100 мс).
  * **name/description**: может быть присвоено `"BaseSignals Burst (3 ops)"` или с уточнением, например `"BaseSignals Burst (3 ops, 100ms)"`.
  * Отдельно фиксируется, что имеется 1 шумовая операция (SubOp3). Если мы не сохраняем её внутрь структуры, то по крайней мере знаем `noise_count = 1` и ее тип `"ValidateData"`.
* Подоперация 5 (`DBCommit`) не входит в кластер, и поскольку рядом других подобных нет, она останется самостоятельной (никакая стратегия её не сгруппирует, если, например, TargetClusterStrategy не сочтёт её частью какой-то своей группы).

## Примеры вывода в логах

### Пример вывода в лог (compact mode)

После завершения основной операции (в которую входили эти подоперации), агрегированный лог может выглядеть так (показывая только секцию мета-операций и сводку для краткости):

```
META-OPERATIONS DETECTED:
⚡ [base_signals_burst_12000] BaseSignals Burst (3 steps, 0.100s, noise: 1)

DETAILED BREAKDOWN:
+--------+-----------------------+------------+--------------+--------+--------+
| Step   | Sub-operation         | Target     | ...          | Status | Time   |
+--------+-----------------------+------------+--------------+--------+--------+
| >>> BaseSignals Burst (Meta-cluster: 3 ops, 100ms, noise: ValidateData)        |
+--------+-----------------------+------------+--------------+--------+--------+
| 1      | SignalA               | base_signals | ...        | OK     | 0.010  |
| 2      | SignalB               | base_signals | ...        | OK     | 0.010  |
| 3      | ValidateData *noise*  | validation   | ...        | OK     | 0.003  |
| 4      | SignalC               | base_signals | ...        | OK     | 0.005  |
+--------+-----------------------+------------+--------------+--------+--------+
| 5      | DBCommit              | database   | ...          | OK     | 0.010  |
+--------+-----------------------+------------+--------------+--------+--------+
SUMMARY: steps 5, successful 5, meta-operations 1 (BaseSignals burst), total time 0.510 s.
```

В этом условном примере:

* В блоке "META-OPERATIONS DETECTED" перечислен наш кластер BaseSignals Burst с указанием, что в нём 3 шага и 0.100s времени, а также пометка `noise: 1` (означающая 1 шумовая операция внутри).
* В "DETAILED BREAKDOWN" (табличном детализированном выводе) кластер отмечен стрелкой `>>>` и пояснением, в скобках указано количество операций и длительность, плюс упоминание шума (название операции ValidateData помечено как noise для ясности). Внутри кластера перечислены три операции base_signals (шаги 1, 2, 4). Обратите внимание: шаг 3 (ValidateData) здесь показан как отдельная строка со пометкой `*noise*` и не входит под мета-кластер, хотя по времени он выполнился между 2 и 4.
* В SUMMARY в конце указывается, что обнаружена 1 мета-операция (BaseSignals burst) среди 5 шагов.

### Пример вывода в JSON (если запрашивается через API)

```json
{
  "operation": "SomeBusinessOperation",
  "meta_operations": [
    {
      "meta_id": "base_signals_burst_12000",
      "name": "BaseSignals Burst",
      "heuristic": "BaseSignalsMetaBurst",
      "sub_operations": [1, 2, 4],  // возможно, списком индексов или полных записей
      "cluster_start_time": 12.000,
      "cluster_end_time": 12.100,
      "execution_time": 0.100,
      "operation_count": 3,
      "noise_count": 1
    }
  ],
  "total_steps": 5,
  "clustered_steps": 3,
  "total_meta_operations": 1,
  "execution_time": 0.510
}
```

Здесь `noise_count: 1` включён в JSON для полноты (при желании можно также перечислить идентификаторы шумовых операций, но это не обязательно). Поле `clustered_steps: 3` указывает, что 3 из 5 шагов вошли в кластеры. Остальные цифры соответствуют нашему сценарию.

## Дополнительные сценарии использования

### Сценарий 1: Множественные burst'ы

**Входные данные:**
- Операции 1-3: base_signals, времена 10.000, 10.050, 10.090 (burst #1)
- Операция 4: другой модуль, время 10.300
- Операции 5-6: base_signals, времена 10.500, 10.560 (burst #2)

**Ожидаемый результат:**
- Два отдельных кластера BaseSignalsMetaBurst
- burst_1: операции 1-3 (длительность 90ms)
- burst_2: операции 5-6 (длительность 60ms)

### Сценарий 2: Единичная операция (ниже min_cluster_size)

**Входные данные:**
- Операция 1: base_signals, время 10.000
- Операции 2-4: другие модули, времена 10.100, 10.200, 10.300

**Ожидаемый результат:**
- Никаких кластеров BaseSignalsMetaBurst не создается
- Все операции остаются индивидуальными

### Сценарий 3: Операции за пределами окна

**Входные данные:**
- Операция 1: base_signals, время 10.000
- Операция 2: base_signals, время 10.150 (150ms после первой, больше окна 100ms)

**Ожидаемый результат:**
- Никаких кластеров не создается (интервал превышает window_ms)
- Обе операции остаются индивидуальными

### Сценарий 4: Сложный шум

**Входные данные:**
- Операция 1: base_signals, время 10.000
- Операции 2-4: другие модули, времена 10.020, 10.040, 10.060
- Операция 5: base_signals, время 10.080

**Ожидаемый результат:**
- Один кластер из операций 1 и 5
- Noise count = 3 (операции 2, 3, 4)
- В summary указаны все типы шумовых операций

## Граничные случаи

### Граничный случай 1: Точно на границе окна

**Конфигурация:** `window_ms = 100`
**Входные данные:**
- Операция 1: base_signals, время 10.000
- Операция 2: base_signals, время 10.100 (ровно 100ms)

**Требуется определить:** Входит ли вторая операция в кластер?
**Рекомендация:** Включать границы (<=), чтобы окно было inclusive.

### Граничный случай 2: Одновременные операции

**Входные данные:**
- Операции 1-2: base_signals, одинаковое время 10.000

**Ожидаемый результат:**
- Кластер из 2 операций с нулевой длительностью

### Граничный случай 3: Изменение min_cluster_size

**Конфигурация:** `min_cluster_size = 3`
**Входные данные:**
- 2 операции base_signals в пределах окна

**Ожидаемый результат:**
- Никаких кластеров (не достигнут минимальный размер)

## Цели этапа

1. **Создать реалистичные примеры** - показать работу стратегии на конкретных данных
2. **Определить формат вывода** - как кластеры отображаются в разных режимах
3. **Покрыть граничные случаи** - сложные сценарии и edge cases
4. **Создать тестовые сценарии** - примеры для unit и integration тестов
5. **Документировать ожидаемое поведение** - четкие спецификации результатов

## Результаты этапа

- [ ] Создан основной пример с пошаговым разбором
- [ ] Определены форматы вывода для всех режимов (compact, detailed, JSON)
- [ ] Документированы сценарии множественных burst'ов
- [ ] Покрыты граничные случаи и edge cases
- [ ] Созданы примеры для разных значений конфигурации
- [ ] Подготовлены тестовые данные для автотестов
- [ ] Документировано поведение при различных типах шума

## Следующий этап

**Этап 5: Критерии приемки и тестирование** - определение всех тестов и критериев для валидации корректности реализации.
